<!DOCTYPE html>
<!-- 
    중요: 이 페이지는 HTTPS 또는 localhost에서만 작동합니다.
    HTTP 또는 file:// 프로토콜에서는 웹캠 접근이 거부되어 얼굴 인식이 작동하지 않습니다.
    
    테스트 방법:
    1. 로컬 서버 실행: python -m http.server 8000 (또는 npx serve)
    2. https://localhost:8000 으로 접속
    3. 또는 GitHub Pages 등 HTTPS 환경에서 테스트
-->
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O디지털 디톡스</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        @font-face {
            font-family: 'Galmuri11';
            src: url('Galmuri11.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        
        body {
            font-family: 'Galmuri11', sans-serif;
            background:#f0f0f0; color:#000; overflow-x:hidden;
            cursor: default;
        }


        .sidebar{ position:fixed; top:0; left:0; bottom:0; width:320px; background:#e0e0e0; border-right:3px solid #333; z-index:60; 
            padding:16px 12px; display:flex; flex-direction:column; gap:12px; pointer-events:none; }
        .sidebar .brand{ font-weight:800; font-size:20px; padding:8px 10px; pointer-events:auto; font-family:'Galmuri11', monospace; }
        .profile-section{ display:flex; flex-direction:column; align-items:center; gap:8px; margin-top:auto; margin-bottom:20px; pointer-events:auto; border-top:2px solid #333; padding-top:20px; margin-left:-12px; margin-right:-12px; padding-left:12px; padding-right:12px; }
        
        .profile-stats{ display:flex; gap:20px; margin-top:6px; }
        .profile-stat{ text-align:center; }
        .profile-stat-number{ font-size:14px; font-weight:bold; color:#000; }
        .profile-stat-label{ font-size:12px; color:#666; margin-top:2px; }
        
        .profile-bio{ text-align:center; margin-top:8px; padding:0 16px; }
        .profile-bio-text{ font-size:13px; color:#333; line-height:1.4; }
        .profile-overload{ margin-bottom:16px; padding:12px; background:#fff; border:2px solid #333; border-radius:8px; text-align:center; }
        .profile-overload .overload-label{ font-size:12px; margin-bottom:6px; color:#666; font-weight:600; }
        .profile-overload .progress-bar{ width:100%; height:8px; background:#333; border:1px solid #555; margin:6px 0; overflow:hidden; border-radius:4px; }
        .profile-overload .progress-fill{ height:100%; background:linear-gradient(90deg,#4CAF50,#FFC107,#FF5722); transition:width 0.3s ease; width:0%; }
        .profile-overload .overload-percentage{ font-size:14px; font-weight:bold; color:#000; margin-top:4px; }
        
        .profile-image{ width:240px; height:240px; border-radius:50%; border:4px solid #333; overflow:hidden; background:#ddd; position:relative; }
        .profile-image img{ width:100%; height:100%; object-fit:cover; }
        .profile-image video{ width:100%; height:100%; object-fit:cover; display:none; }
        .profile-image canvas{ width:100%; height:100%; object-fit:cover; border-radius:50%; transform: scaleX(-1); }
        .profile-name{ font-weight:700; font-size:20px; color:#000; text-align:center; }
        .menu{ display:flex; flex-direction:column; gap:6px; margin-top:8px; }
        .menu a{ display:flex; align-items:center; gap:12px; padding:10px 12px; color:#000; text-decoration:none; font-weight:600; 
            border:2px solid #333; margin:2px 0; pointer-events:auto; }
        .menu a:hover{ background:#ccc; }
        .sidebar .spacer{ flex:1; }


        .explore-header, .explore-section{ margin-left:320px; }


        @media (max-width:1024px){ .sidebar{ width:72px; padding:16px 8px; } .menu a span.label{ display:none; } .explore-header, 
        .explore-section{ margin-left:72px; } }



        
        .main-container{ position:relative; min-height:200vh; z-index:1; }

        
        .explore-header{ position:fixed; top:0; left:0; width:100%; background:#000; border-bottom:3px solid #333; padding:20px 0; z-index:100; 
            transition:all .3s ease; }
        .explore-header.glitch{ animation:glitch .3s infinite; }
        @keyframes glitch{ 0%{transform:translateX(0)} 20%{transform:translateX(-2px)} 40%{transform:translateX(2px)} 
        60%{transform:translateX(-1px)} 80%{transform:translateX(1px)} 100%{transform:translateX(0)} }
        .header-content{ max-width:1200px; margin:0 auto; padding:0 20px; display:flex; justify-content:space-between; align-items:center; }
        .logo{ font-size:2rem; font-weight:bold; color:#e50914; }
        .nav-menu{ display:flex; gap:30px; list-style:none; width:100%; justify-content:space-between; }
        .nav-menu a{ color:#fff; text-decoration:none; font-size:1.1rem; transition:color .3s ease; }
        .nav-menu a:hover{ color:#e50914; }

        
        .explore-header{ position:sticky; top:0; background:#fff; z-index:50; border-bottom:1px solid rgba(0,0,0,.08); }
        
        /* 헤더를 클리닝 모드에서 투명하게 */
        body.cleaning-mode .explore-header,
        .explore-header.cleaned{
          background: transparent !important;
          border-bottom-color: transparent !important;
        }
        
        /* 내부 패딩 영역도 투명하게 */
        body.cleaning-mode .explore-inner,
        .explore-header.cleaned .explore-inner{
          background: transparent !important;
        }
        .explore-inner{ width:100%; padding:12px 20px 12px 20px; display:flex; gap:12px; align-items:center; }
        .brand{ font-weight:800; letter-spacing:.5px; font-family:'Galmuri11', monospace; margin-right:24px; }
        .search{ width:900px; max-width:1080px; background:#fff; color:#000; border:2px solid #333; padding:10px 12px; }

        .explore-section{ padding:12px; max-width:1200px; margin:0 auto; margin-left:320px; background:#f0f0f0; }
        .explore-grid{ display:grid; grid-template-columns:repeat(5,1fr); gap:2px; }
        
        
        .explore-grid .thumbnail{ min-width:auto; width:100%; position:relative; background:#fff; border:2px solid #333; }
        .explore-grid .thumbnail::before{ content:""; display:block; padding-top:100%; }
        
        .explore-grid .thumbnail.tall-2::before{ padding-top:200%; }
        .explore-grid .thumbnail > *{ position:absolute; inset:0; }
        
        /* 썸네일 이미지 필터 */
        .explore-grid .thumbnail img{
            filter: grayscale(20%) contrast(1.1) brightness(0.9) saturate(0.8);
            transition: filter 0.3s ease;
        }
        
        .explore-grid .thumbnail:hover img{
            filter: grayscale(10%) contrast(1.2) brightness(1.0) saturate(0.9);
        }
        
        .section-title{ font-size:1.5rem; margin-bottom:20px; color:#fff; }
        .thumbnail-row{ display:flex; gap:10px; margin-bottom:40px; overflow-x:auto; padding-bottom:10px; }

        .thumbnail{ min-width:200px; height:300px; background:linear-gradient(45deg,#333,#555); position:relative; 
            cursor:pointer; overflow:hidden; flex:0 0 auto; }

        
        .thumbnail.falling{ position:fixed; z-index:10; pointer-events:auto; opacity:1 !important; will-change:transform,top,left; }
        
        
        .cleaning-mode .thumbnail.falling{ pointer-events:auto; }

        
        .thumbnail.already-fallen{ visibility:hidden; }

        .thumbnail.destroyed{ animation:destroy .5s ease-out forwards; pointer-events:none; }
        
        .random-window{ position:fixed !important; width:300px !important; height:150px !important; background:#fff !important; 
            border:3px solid #000 !important; z-index:9999 !important; cursor:pointer; display:flex !important; align-items:center; justify-content:center; font-family:'Galmuri11',sans-serif; font-size:14px; color:#000 !important; opacity:1 !important; visibility:visible !important; }
        
        .close-button{ position:absolute !important; top:5px !important; right:5px !important; width:20px !important; height:20px 
            !important; background:#000 !important; border:2px solid #000 !important; border-radius:50% !important; color:#fff 
            !important; display:flex !important; align-items:center !important; justify-content:center !important; font-size:12px !important; font-weight:bold !important; cursor:pointer !important; z-index:10000 !important; }
        
        .close-button:hover{ background:#333 !important; }
        
       
        .cleaning-mode-switch{ position:fixed; bottom:20px; right:20px; z-index:10000; width:180px; height:180px; border-radius:50%;
             background:#fff; border:2px solid #000; display:flex; align-items:center; justify-content:center; font-family:'Galmuri11',sans-serif; font-size:21px; font-weight:bold; text-align:center; line-height:1.2; cursor:pointer; user-select:none; transition:all 0.3s ease; opacity:0; transform:translateY(20px) scale(0.8); 
             filter: drop-shadow(0 0 8px rgba(255,255,255,0.8)) drop-shadow(0 0 16px rgba(255,255,255,0.4)) drop-shadow(0 0 24px rgba(255,255,255,0.2)); }
        
        .cleaning-mode-switch.cleaned{ 
            opacity: 0 !important; 
            visibility: hidden !important; 
            transform: translateY(20px) scale(0.8) !important; 
            pointer-events: none !important; 
        }
        
        .cleaning-mode-switch.visible{ opacity:1; transform:translateY(0) scale(1); }
        
        .cleaning-mode-switch:hover{ background:#f0f0f0; transform:scale(1.1); }
        
        .cleaning-mode-switch.active{ background:#000; color:#fff; animation: cleaningPulse 1.5s ease-in-out infinite; }
        
        .cleaning-mode-switch.active:hover{ transform:scale(1.1); }
        
        @keyframes cleaningPulse {
            0% { 
                transform: scale(1); 
                filter: drop-shadow(0 0 8px rgba(255,255,255,0.8)) drop-shadow(0 0 16px rgba(255,255,255,0.4)) drop-shadow(0 0 24px rgba(255,255,255,0.2));
                background: #000;
            }
            25% { 
                transform: scale(1.05); 
                filter: drop-shadow(0 0 12px rgba(255,255,255,1)) drop-shadow(0 0 24px rgba(255,255,255,0.6)) drop-shadow(0 0 36px rgba(255,255,255,0.3));
                background: #ff0000;
            }
            50% { 
                transform: scale(1.1); 
                filter: drop-shadow(0 0 16px rgba(255,255,255,1.2)) drop-shadow(0 0 32px rgba(255,255,255,0.8)) drop-shadow(0 0 48px rgba(255,255,255,0.4));
                background: #ff4444;
            }
            75% { 
                transform: scale(1.05); 
                filter: drop-shadow(0 0 12px rgba(255,255,255,1)) drop-shadow(0 0 24px rgba(255,255,255,0.6)) drop-shadow(0 0 36px rgba(255,255,255,0.3));
                background: #ff0000;
            }
            100% { 
                transform: scale(1); 
                filter: drop-shadow(0 0 8px rgba(255,255,255,0.8)) drop-shadow(0 0 16px rgba(255,255,255,0.4)) drop-shadow(0 0 24px rgba(255,255,255,0.2));
                background: #000;
            }
        }
        
        
        .detox-complete{ position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); font-size:2rem; font-weight:bold; 
            color:#000; text-align:center; z-index:20000; opacity:0; transition:opacity 1s ease; font-family:'Galmuri11',sans-serif; }
        
        .detox-complete.visible{ opacity:1; }
        
        /* (삭제/주석 처리 권장) 기존 SVG 사각형 커서 */
        /*
        body.cleaning-mode{ cursor:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="2" y="2" width="20" height="20" fill="none" stroke="%23000" stroke-width="2"/><rect x="6" y="6" width="12" height="12" fill="%23000"/></svg>') 12 12, auto; }
        */
        
        
        .cleaning-mode .thumbnail, .cleaning-mode .thumbnail.falling, .cleaning-mode .random-window, .cleaning-mode .menu a, 
        .cleaning-mode .search, .cleaning-mode .brand, .cleaning-mode .profile-section, .cleaning-mode .profile-image, .cleaning-mode .profile-name{ transition:none; }
        
        
        .cleaning-mode .sidebar{ transition:opacity 0.5s ease; }
        
        .cleaning-mode .sidebar.cleaned{ opacity:0; }
        .cleaning-mode .profile-section.cleaned, .cleaning-mode .profile-image.cleaned, .cleaning-mode .profile-name.cleaned{ opacity:0; }
        
        
        .search {
            transition: opacity 0.5s ease;
        }
        
        .search.cleaned {
            opacity: 0 !important;
        }
        
        
        @keyframes destroy{
            0%{ transform:scale(1) rotate(0deg); opacity:1; }
            50%{ transform:scale(1.1) rotate(10deg); opacity:.85; }
            100%{ transform:scale(.9) rotate(0deg); opacity:0; }
        }

        .thumbnail-content{
            position:absolute; inset:auto 0 0 0;
            padding:20px; color:#fff;
        }
        .thumbnail-title{ font-size:1rem; font-weight:bold; margin-bottom:5px; }
        .thumbnail-info{ font-size:.8rem; opacity:.8; }

        

        

        @media (max-width:768px){
            .thumbnail{ min-width:150px; height:225px; }
            .nav-menu{ gap:15px; }
        }

        /* Entry Gate */
        #entry-gate{
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.94);
            color:#f5f5f5; z-index: 30000;
            display:flex; align-items:center; justify-content:center;
            opacity:1; transition: opacity .35s ease, visibility .35s ease;
            visibility: visible;
        }
        #entry-gate.hidden{ opacity:0; visibility:hidden; }
        
        /* Second Gate */
        #second-gate{
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.9); 
            color:#f5f5f5; z-index: 30000;
            display:flex; align-items:center; justify-content:center;
            opacity:1; transition: opacity .35s ease, visibility .35s ease;
            visibility: visible;
        }
        #second-gate.hidden{ opacity:0; visibility:hidden; }
        
        /* Third Gate */
        #third-gate{
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.9); 
            color:#f5f5f5; z-index: 30000;
            display:flex; align-items:center; justify-content:center;
            opacity:1; transition: opacity .35s ease, visibility .35s ease;
            visibility: visible;
        }
        #third-gate.hidden{ opacity:0; visibility:hidden; }
        
        /* 오버레이 위로 올릴 때 쓰는 모드 */
        .profile-gauge.portal {
            position: fixed !important;
            z-index: 40000 !important; /* 오버레이(30000)보다 크게 */
            left: 0; top: 0; /* JS에서 실제 좌표 주입 */
            pointer-events: auto; /* 필요하면 클릭 가능 */
        }

        #entry-gate .gate-inner, #second-gate .gate-inner, #third-gate .gate-inner{
            max-width: 720px; padding: 32px 24px; text-align: center;
            font-family:'Galmuri11', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .gate-title{
            font-size: clamp(28px, 4vw, 40px);
            font-weight: 400; letter-spacing: .5px; margin-bottom: 14px;
            overflow: hidden;
            white-space: nowrap;
            border-right: 2px solid #fff;
            animation: blink 1s infinite;
        }
        
        .gate-title.typing{
            border-right: 2px solid #fff;
            animation: blink 1s infinite;
        }
        
        .gate-title.completed{
            border-right: none;
            animation: none;
        }
        
        @keyframes blink {
            0%, 50% { border-color: #fff; }
            51%, 100% { border-color: transparent; }
        }
        .gate-sub{
            font-size: 15px; line-height: 1.7; color:#d7d7d7; margin-bottom: 18px;
        }
        .gate-instr{
            font-size: 16px; line-height:1.8; margin-bottom: 28px; color:#fff;
        }
        .gate-instr em{ font-style: normal; text-decoration: underline; }

        .gate-btn{
            appearance:none; border:2px solid #fff; background:#fff; color:#000;
            font-weight: 800; padding: 12px 18px; border-radius: 10px;
            cursor:pointer; transition: transform .12s ease;
            margin-top: 40px;
        }
        .gate-btn:active{ transform: translateY(1px); }

        .gate-hint{
            margin-top: 14px; font-size:12px; color:#bdbdbd;
            opacity:.9;
        }

        /* 게이트가 켜진 동안 스크롤 잠금 */
        body.gate-lock{
            overflow: hidden;
        }
        
        /* 엔트리 게이트가 보이는 동안 스크롤 완전 차단 */
        body:not(.gate-unlocked) {
            overflow: hidden;
        }

        /* ===== 원형 게이지 (프로필 외곽) ===== */
        .profile-gauge{
          position: relative;
          width: 280px; height: 280px;
          display: grid; place-items:center;
        }

        /* 프로필 이미지를 게이지 안쪽에 정확히 가운데 */
        .profile-gauge .profile-image{
          position:absolute;
          width:240px; height:240px;
          border-radius:50%;
          border:2px solid #333;
          overflow:hidden; background:#ddd;
          z-index:2;
        }

        /* 중앙 퍼센트 라벨 */
        .gauge-label{
          position:absolute;
          z-index:3;
          font-weight:800;
          font-size:24px;
          color:#000;
          text-align:center;
          user-select:none;
        }

        /* 게이지 SVG는 뒤에 */
        .gauge{
          position:absolute;
          inset:0;
          transform: rotate(-90deg); /* 12시 방향에서 시작하도록 */
          z-index:1;
        }

        /* 게이지 배경 원 */
        .gauge-bg{
          fill:none;
          stroke:#d0d0d0;
          stroke-width:4;
        }

        /* 게이지 진행 원 */
        .gauge-fill{
          fill:none;
          stroke:#ff0000;
          stroke-width:8;
          stroke-linecap:butt;   /* ← round 대신 butt */
          transition: stroke-dashoffset .35s ease;
        }

        /* 사이드바 축소 시(모바일) 게이지 크기도 자동 축소 */
        @media (max-width:1024px){
          .profile-gauge{ width:168px; height:168px; }
          .profile-gauge .profile-image{ width:128px; height:128px; border-width:2px; }
          .gauge-label{ font-size:18px; }
        }

        /* ===== 프로필 글리치 효과 ===== */
        .profile-gauge.glitch .profile-image{
          animation: profileGlitch 0.3s ease-in-out;
        }

        .profile-gauge.glitch .gauge-label{
          animation: labelGlitch 0.3s ease-in-out;
        }

        /* 강도별 글리치 효과 */
        .profile-gauge.glitch.mild .profile-image{
          animation: profileGlitchMild 0.3s ease-in-out;
        }

        .profile-gauge.glitch.mild .gauge-label{
          animation: labelGlitchMild 0.3s ease-in-out;
        }

        .profile-gauge.glitch.moderate .profile-image{
          animation: profileGlitchModerate 0.3s ease-in-out;
        }

        .profile-gauge.glitch.moderate .gauge-label{
          animation: labelGlitchModerate 0.3s ease-in-out;
        }

        .profile-gauge.glitch.severe .profile-image{
          animation: profileGlitchSevere 0.3s ease-in-out;
        }

        .profile-gauge.glitch.severe .gauge-label{
          animation: labelGlitchSevere 0.3s ease-in-out;
        }

        /* 약한 글리치 (0-30%) */
        @keyframes profileGlitchMild {
          0% { 
            filter: hue-rotate(0deg) saturate(1) brightness(1);
            transform: translate(0, 0) scale(1);
          }
          50% { 
            filter: hue-rotate(30deg) saturate(1.2) brightness(1.05);
            transform: translate(-1px, 0.5px) scale(1.005);
          }
          100% { 
            filter: hue-rotate(0deg) saturate(1) brightness(1);
            transform: translate(0, 0) scale(1);
          }
        }

        @keyframes labelGlitchMild {
          0% { 
            color: #000;
            text-shadow: none;
            transform: translate(0, 0);
          }
          50% { 
            color: #ff6666;
            text-shadow: 1px 0 0 #66ff66;
            transform: translate(-0.5px, 0);
          }
          100% { 
            color: #000;
            text-shadow: none;
            transform: translate(0, 0);
          }
        }

        /* 중간 글리치 (30-70%) */
        @keyframes profileGlitchModerate {
          0% { 
            filter: hue-rotate(0deg) saturate(1) brightness(1);
            transform: translate(0, 0) scale(1);
          }
          25% { 
            filter: hue-rotate(60deg) saturate(1.5) brightness(1.1);
            transform: translate(-2px, 1px) scale(1.01);
          }
          50% { 
            filter: hue-rotate(120deg) saturate(0.8) brightness(0.9);
            transform: translate(2px, -1px) scale(0.99);
          }
          75% { 
            filter: hue-rotate(180deg) saturate(1.3) brightness(1.05);
            transform: translate(-1px, 1px) scale(1.005);
          }
          100% { 
            filter: hue-rotate(0deg) saturate(1) brightness(1);
            transform: translate(0, 0) scale(1);
          }
        }

        @keyframes labelGlitchModerate {
          0% { 
            color: #000;
            text-shadow: none;
            transform: translate(0, 0);
          }
          25% { 
            color: #ff0000;
            text-shadow: 1px 0 0 #00ff00, -1px 0 0 #0000ff;
            transform: translate(-1px, 0);
          }
          50% { 
            color: #00ff00;
            text-shadow: -1px 0 0 #ff0000, 1px 0 0 #0000ff;
            transform: translate(1px, 0);
          }
          75% { 
            color: #0000ff;
            text-shadow: 1px 0 0 #ff0000, -1px 0 0 #00ff00;
            transform: translate(-0.5px, 0);
          }
          100% { 
            color: #000;
            text-shadow: none;
            transform: translate(0, 0);
          }
        }

        /* 심한 글리치 (70-100%) */
        @keyframes profileGlitchSevere {
          0% { 
            filter: hue-rotate(0deg) saturate(1) brightness(1);
            transform: translate(0, 0) scale(1);
          }
          20% { 
            filter: hue-rotate(90deg) saturate(2) brightness(1.2);
            transform: translate(-3px, 2px) scale(1.03);
          }
          40% { 
            filter: hue-rotate(180deg) saturate(0.5) brightness(0.8);
            transform: translate(3px, -2px) scale(0.97);
          }
          60% { 
            filter: hue-rotate(270deg) saturate(1.8) brightness(1.15);
            transform: translate(-2px, 3px) scale(1.02);
          }
          80% { 
            filter: hue-rotate(360deg) saturate(0.7) brightness(0.85);
            transform: translate(2px, -3px) scale(0.98);
          }
          100% { 
            filter: hue-rotate(0deg) saturate(1) brightness(1);
            transform: translate(0, 0) scale(1);
          }
        }

        @keyframes labelGlitchSevere {
          0% { 
            color: #000;
            text-shadow: none;
            transform: translate(0, 0);
          }
          20% { 
            color: #ff0000;
            text-shadow: 3px 0 0 #00ff00, -3px 0 0 #0000ff;
            transform: translate(-2px, 0);
          }
          40% { 
            color: #00ff00;
            text-shadow: -3px 0 0 #ff0000, 3px 0 0 #0000ff;
            transform: translate(2px, 0);
          }
          60% { 
            color: #0000ff;
            text-shadow: 3px 0 0 #ff0000, -3px 0 0 #00ff00;
            transform: translate(-2px, 0);
          }
          80% { 
            color: #ff00ff;
            text-shadow: -3px 0 0 #00ff00, 3px 0 0 #ff0000;
            transform: translate(2px, 0);
          }
          100% { 
            color: #000;
            text-shadow: none;
            transform: translate(0, 0);
          }
        }

        /* === Cleaning Mode: Vacuum cursor (follower) === */
        #vacuum-cursor{
          position:fixed; left:0; top:0;
          width:360px; height:360px;
          pointer-events:none;
          transform:translate(-50%,-50%);  /* 중앙정렬은 래퍼에 유지 */
          z-index:99999; display:none;
          filter: drop-shadow(0 0 4px rgba(255,255,255,.6)) drop-shadow(0 0 8px rgba(255,255,255,.4)) drop-shadow(0 0 12px rgba(255,255,255,.2));
        }
        #vacuum-img{
          position:absolute; inset:0;
          background:url('vaccum.png') no-repeat center / contain;
          /* 회전은 여기에만 줄 거예요 */
        }

        /* 클리닝 모드일 때 실제 커서 숨기기 */
        body.cleaning-mode{
          cursor: none !important;
        }

    </style>
</head>
<body>
    <!-- Vacuum Cursor Follower -->
    <div id="vacuum-cursor">
      <div id="vacuum-img"></div>
    </div>


    <!-- Entry Gate Overlay -->
    <div id="entry-gate" aria-hidden="false">
        <div class="gate-inner">
            <h1 class="gate-title"></h1>
            <button id="gate-start" type="button" class="gate-btn">다음</button>
        </div>
    </div>
    
    <!-- Second Gate Overlay -->
    <div id="second-gate" aria-hidden="true" class="hidden">
        <div class="gate-inner">
            <h1 class="gate-title"></h1>
            <button id="second-next" type="button" class="gate-btn">다음</button>
        </div>
    </div>
    
    <!-- Third Gate Overlay -->
    <div id="third-gate" aria-hidden="true" class="hidden">
        <div class="gate-inner">
            <h1 class="gate-title"></h1>
            <button id="third-start" type="button" class="gate-btn">시작하기</button>
        </div>
    </div>

    <aside class="sidebar">
        <div class="brand">Detoxgram</div>
        <nav class="menu">
            <a href="javascript:void(0)"><span class="label">홈</span></a>
            <a href="javascript:void(0)"><span class="label">탐색</span></a>
            <a href="javascript:void(0)"><span class="label">메시지</span></a>
            <a href="javascript:void(0)"><span class="label">프로필</span></a>
        </nav>
        <div class="spacer"></div>
        <div class="profile-section">
          <div class="profile-gauge">
            <!-- 원형 게이지 (프로필 외곽) -->
            <svg class="gauge" viewBox="0 0 140 140" aria-hidden="true">
              <!-- 배경 원 -->
              <circle class="gauge-bg" cx="70" cy="70" r="62"></circle>
              <!-- 진행 원 -->
              <circle class="gauge-fill" id="gauge-fill" cx="70" cy="70" r="62"></circle>
            </svg>

            <!-- 프로필 이미지 (가운데) -->
            <div class="profile-image">
              <video id="profile-video" autoplay muted style="display:none;"></video>
              <canvas id="profile-canvas" width="240" height="240"></canvas>
            </div>

            <!-- 퍼센트 라벨 (원 안 중앙) -->
            <div class="gauge-label"><span id="sidebar-overload">0</span>%</div>
          </div>

          <div class="profile-name">KimYuna</div>
          
          <!-- 팔로잉/팔로워 통계 -->
          <div class="profile-stats">
            <div class="profile-stat">
              <div class="profile-stat-number">1,234</div>
              <div class="profile-stat-label">팔로잉</div>
            </div>
            <div class="profile-stat">
              <div class="profile-stat-number">5,678</div>
              <div class="profile-stat-label">팔로워</div>
            </div>
          </div>
          
          <!-- 소개 메시지 -->
          <div class="profile-bio">
            <div class="profile-bio-text">
              디지털 과부화 아티스트<br>
              스크롤을 내리는게 취미다.
            </div>
          </div>
        </div>
    </aside>

    <header class="explore-header">
        <div class="explore-inner">
            <div class="brand">Explore</div>
            <input id="search" class="search" placeholder="검색" />
        </div>
    </header>

    <main class="explore-section">
        <div class="explore-grid" id="explore-grid"></div>
    </main>
    
    <div class="cleaning-mode-switch" id="cleaning-mode-switch">
        CLEANING<br>MODE
    </div>
    
    <!-- 숨겨진 과부화 퍼센트 요소 (로직용) -->
    <div id="overload-percentage" style="display: none;">0</div>
    
    
    
    <div class="detox-complete" id="detox-complete">
        DETOX COMPLETE!
    </div>

    <script>
        // 1) 브라우저 스크롤 복원 기능 비활성화
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }

        // 2) 페이지가 보여질 때도 최상단으로
        window.addEventListener('pageshow', () => {
            // 일부 브라우저는 복원을 pageshow에 적용하므로, 약간 뒤에 강제로 0으로
            setTimeout(() => window.scrollTo(0, 0), 0);
        });

        const contentData = {
            'trending': [
                { title:'', info:'', image:'1.jpg' },
                { title:'', info:'', image:'2.jpg' },
                { title:'', info:'', image:'3.jpg' },
                { title:'', info:'', image:'4.jpg' },
                { title:'', info:'', image:'5.jpg' },
                { title:'', info:'', image:'6.jpg' },
                { title:'', info:'', image:'7.jpg' },
                { title:'', info:'', image:'8.jpg' },
                { title:'', info:'', image:'9.jpg' },
                { title:'', info:'', image:'10.jpg' },
                { title:'', info:'', image:'11.jpg' },
                { title:'', info:'', image:'12.jpg' },
                { title:'', info:'', image:'13.jpg' },
                { title:'', info:'', image:'14.jpg' },
                { title:'', info:'', image:'15.jpg' },
                { title:'', info:'', image:'16.jpg' },
                { title:'', info:'', image:'17.jpg' },
                { title:'', info:'', image:'18.jpg' },
                { title:'', info:'', image:'19.jpg' },
                { title:'', info:'', image:'20.jpg' }
            ],
            'recommended': [
                { title:'', info:'', image:'21.jpg' },
                { title:'', info:'', image:'22.jpg' },
                { title:'', info:'', image:'23.jpg' },
                { title:'', info:'', image:'24.jpg' },
                { title:'', info:'', image:'25.jpg' }
            ],
            'lifestyle': [
                { title:'', info:'', image:'26.jpg' },
                { title:'', info:'', image:'27.jpg' },
                { title:'', info:'', image:'28.jpg' },
                { title:'', info:'', image:'29.jpg' },
                { title:'', info:'', image:'30.jpg' }
            ],
            'nature': [
                { title:'', info:'', image:'31.jpg' },
                { title:'', info:'', image:'32.jpg' },
                { title:'', info:'', image:'33.jpg' },
                { title:'', info:'', image:'34.jpg' },
                { title:'', info:'', image:'35.jpg' }
            ],
            'city': [
                { title:'', info:'', image:'36.jpg' },
                { title:'', info:'', image:'37.jpg' },
                { title:'', info:'', image:'38.jpg' },
                { title:'', info:'', image:'39.jpg' },
                { title:'', info:'', image:'40.jpg' }
            ],
            'people': [
                { title:'', info:'', image:'41.jpg' },
                { title:'', info:'', image:'42.jpg' },
                { title:'', info:'', image:'43.jpg' },
                { title:'', info:'', image:'44.jpg' },
                { title:'', info:'', image:'45.jpg' }
            ],
            'tech': [
                { title:'', info:'', image:'46.jpg' },
                { title:'', info:'', image:'47.jpg' },
                { title:'', info:'', image:'48.jpg' },
                { title:'', info:'', image:'49.jpg' },
                { title:'', info:'', image:'50.jpg' }
            ],
            'creative': [
                { title:'', info:'', image:'51.jpg' },
                { title:'', info:'', image:'52.jpg' },
                { title:'', info:'', image:'53.jpg' },
                { title:'', info:'', image:'54.jpg' },
                { title:'', info:'', image:'55.jpg' }
            ],
            'misc': [
                { title:'', info:'', image:'56.jpg' },
                { title:'', info:'', image:'57.jpg' },
                { title:'', info:'', image:'58.jpg' },
                { title:'', info:'', image:'59.jpg' },
                { title:'', info:'', image:'60.jpg' }
            ]
        };

        let scrollY = 0;
        let fallingThumbnails = [];
        let stackedThumbnails = [];
        let destroyedCount = 0;
        let totalThumbnails = 0;
        let isGlitching = false;
        let isCleaningMode = false;
        let detoxComplete = false;
        let cleaningModeStartPercent = 0;
        let baselineCleanedThumbs = 0;
        let baselineTotalThumbs = 0;

        const GRAVITY = 0.5;
        const BOUNCE  = 0.08;
        const FRICTION = 0.95;
        const MIN_VELOCITY = 0.8;
        const MAX_SPEED = 10;
        const PILE_GROWTH = 0.12;
        const PILE_CAP    = 0.45;
        const SETTLE_X_JITTER = 8;
        let pileHeight = 0;

        function getLocalPileHeight(x, w){
            const xCenter = x + w/2;
            let h = 0;
            const OVERLAP_SLACK = 20;
            for(const s of stackedThumbnails){
                const sCenter = s.x + s.width/2;
                const dx = Math.abs(xCenter - sCenter);
                const halfSum = (w + s.width)/2;
                if(dx - OVERLAP_SLACK < halfSum){
                    h += s.height * PILE_GROWTH;
                }
            }
            const cap = window.innerHeight * PILE_CAP;
            return Math.min(cap, h);
        }

        function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

        // 클리닝 진행률을 기준선 대비로 계산하는 함수
        function getCleaningProgressRelative() {
            const originals = document.querySelectorAll('.explore-grid .thumbnail');
            const cleanedNow = Array.from(originals).filter(thumb =>
                thumb.classList.contains('destroyed') ||
                thumb.classList.contains('already-fallen') ||
                thumb.style.visibility === 'hidden'
            ).length;

            const deltaCleaned = Math.max(0, cleanedNow - baselineCleanedThumbs);
            const deltaTotal = Math.max(1, baselineTotalThumbs - baselineCleanedThumbs);

            return deltaCleaned / deltaTotal; // 0~1
        }

        // 프로필 과부화 표시 업데이트 함수
        function updateProfileOverload(overloadPercent) {
            const profileOverloadPercentage = document.getElementById('profile-overload-percentage');
            const profileProgressFill = document.getElementById('profile-progress-fill');
            
            if (profileOverloadPercentage && profileProgressFill) {
                profileOverloadPercentage.textContent = overloadPercent;
                profileProgressFill.style.width = overloadPercent + '%';
            }
        }

        function init(){
            createThumbnails();
            setupEventListeners();
            totalThumbnails = document.querySelectorAll('.thumbnail').length;
        }

        function createThumbnails(){
            const grid = document.getElementById('explore-grid');
            if(!grid) return;

            const pools = Object.values(contentData).flat();
            const TOTAL = 80;
            for(let i=0;i<TOTAL;i++){
                const item = pools[Math.floor(Math.random()*pools.length)];
                const t = document.createElement('div');
                t.className = 'thumbnail';
                const r = Math.random();
                if(r < 0.12) t.classList.add('tall-3');
                else if(r < 0.32) t.classList.add('tall-2');

                if(item.image) {
                    t.style.background = `url('${item.image}') center/cover`;
                } else {
                    t.style.background = `linear-gradient(45deg, ${item.color}, ${item.color}dd)`;
                }
                
                t.innerHTML = `
                    <div class="thumbnail-content">
                        <div class="thumbnail-title">${item.title}</div>
                        <div class="thumbnail-info">${item.info}</div>
                    </div>`;
                grid.appendChild(t);
            }
        }

        function setupEventListeners(){
            window.addEventListener('scroll', handleScroll, { passive: true });
            document.addEventListener('click', handleClick);
            window.addEventListener('resize', ()=>{});
            
            document.getElementById('cleaning-mode-switch').addEventListener('click', toggleCleaningMode);
            
            
            document.addEventListener('mousemove', function(e) {
                window.mouseX = e.clientX;
                window.mouseY = e.clientY;
            });
            
            document.addEventListener('mouseover', function(e) {
                if(isCleaningMode) {
                    const thumbnail = e.target.closest('.thumbnail');
                    const randomWindow = e.target.closest('.random-window');
                    const menuItem = e.target.closest('.menu a');
                    const searchInput = e.target.closest('.search');
                    const brandElement = e.target.closest('.brand');
                    const profileElement = e.target.closest('.profile-section, .profile-image, .profile-name');
                    const cleaningSwitch = e.target.closest('.cleaning-mode-switch');
                    
                    if(thumbnail && !thumbnail.classList.contains('destroyed')) {
                        cleanElement(thumbnail);
                    } else if(randomWindow) {
                        cleanElement(randomWindow);
                    } else if(menuItem && !menuItem.classList.contains('cleaned')) {
                        cleanElement(menuItem);
                    } else if(searchInput && !searchInput.classList.contains('cleaned')) {
                        cleanElement(searchInput);
                    } else if(brandElement && !brandElement.classList.contains('cleaned')) {
                        cleanElement(brandElement);
                    } else if(profileElement && !profileElement.classList.contains('cleaned')) {
                        cleanElement(profileElement);
                    } else if(cleaningSwitch && !cleaningSwitch.classList.contains('cleaned')) {
                        cleanElement(cleaningSwitch);
                    }
                }
            });
            
            document.addEventListener('mouseover', function(e) {
                if(isCleaningMode) {
                    const exploreHeader = e.target.closest('.explore-header');
                    const searchInput = document.querySelector('.search');
                    
                    if(exploreHeader && searchInput && !searchInput.classList.contains('cleaned')) {
                        cleanElement(searchInput);
                    }
                }
            });
        }

        let lastScrollTime = 0;
        let lastScrollY = 0;
        const SCROLL_SLOWDOWN = 0.2;
        function handleScroll(){
            const now = Date.now();
            if(now - lastScrollTime < 100) return; // 더 자주 업데이트하되 부담 줄임
            lastScrollTime = now;

            scrollY = window.scrollY;

            const scrollingDown = scrollY > lastScrollY;
            lastScrollY = scrollY;

            // requestAnimationFrame으로 UI 업데이트 최적화
            requestAnimationFrame(() => {
                if(scrollingDown && scrollY > 100) startGravityAnimation();
                if(scrollY > 500 && !isGlitching) startGlitchEffect();
                
                if(scrollingDown && scrollY > 200 && Math.random() < 0.3) createRandomWindow();
                
                updateCleaningSwitchVisibility();
            });
        }

        window.addEventListener('wheel', (e)=>{
            if(e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) return;
            e.preventDefault();
            window.scrollBy({ top: e.deltaY * SCROLL_SLOWDOWN, behavior: 'auto' });
        }, { passive:false });

        function startGravityAnimation(){
            const candidates = document.querySelectorAll('.thumbnail:not(.falling):not(.destroyed):not(.already-fallen)');
            const visible = Array.from(candidates).filter(t=>{
                const r = t.getBoundingClientRect();
                return r.top < window.innerHeight && r.bottom > 0;
            });
            
            const hidden = Array.from(candidates).filter(t=>{
                const r = t.getBoundingClientRect();
                return r.bottom <= 0;
            });
            
            hidden.forEach(th => {
                th.classList.add('already-fallen');
                th.style.visibility = 'hidden';
            });

            const batch = Math.min(1, Math.ceil(visible.length * 0.03));
            let count = 0;

            visible.forEach(th=>{
                if(count >= batch) return;
                if(Math.random() < 0.25){
                    makeThumbnailFall(th);
                    th.classList.add('already-fallen');
                    count++;
                }
            });
        }

        function makeThumbnailFall(original){
            const rect = original.getBoundingClientRect();
            const clone = original.cloneNode(true);
            clone.classList.add('falling');

            const width = rect.width;
            const height = rect.height;
            const x = rect.left;
            const y = rect.top;

            const cs = getComputedStyle(original);
            Object.assign(clone.style, {
                position: 'fixed',
                left: x + 'px',
                top: y + 'px',
                width: width + 'px',
                height: height + 'px',
                zIndex: '10',
                pointerEvents: isCleaningMode ? 'auto' : 'none',
                opacity: '1',
                background: cs.background || original.style.background,
                border: '2px solid #333',
                transform: 'translateZ(0)'
            });

            document.body.appendChild(clone);

            const obj = {
                element: clone,
                width, height,
                x, y,
                velocityX: (Math.random()*2 - 1) * 2.5,
                velocityY: 3.0,
                rotation: 0,
                rotationSpeed: 0,
                isStacked: false,
                rollBias: (Math.random() < 0.5 ? -1 : 1) * (1.0 + Math.random()*0.8)
            };
            fallingThumbnails.push(obj);
            
            makeDraggable(clone);
        }

        function handleClick(e){
            
            if(isCleaningMode) return;
            
            const th = e.target.closest('.thumbnail');
            if(!th) return;
            if(th.classList.contains('destroyed')) return;
            createRandomWindow();
            
            // 썸네일 클릭 시 과부화 수치 1% 증가
            const overloadPercentage = document.getElementById('overload-percentage');
            const progressFill = document.getElementById('progress-fill');
            if (overloadPercentage && progressFill) {
                let currentPercent = parseInt(overloadPercentage.textContent) || 0;
                currentPercent = Math.min(100, currentPercent + 1);
                overloadPercentage.textContent = currentPercent;
                progressFill.style.width = currentPercent + '%';
            }
        }

        // ===== YouTube Real Video IDs =====
        function getRandomYouTubeVideo() {
            // 실제 존재하는 유튜브 비디오 ID들
            const realVideoIds = [
                // 인기 동영상들
                'dQw4w9WgXcQ', // Rick Astley - Never Gonna Give You Up
                '2-s8dLibleg', // YouTube Shorts 예시
                'jNQXAC9IVRw', // Me at the zoo (첫 유튜브 동영상)
                'kJQP7kiw5Fk', // Despacito
                'YQHsXMglC9A', // Hello - Adele
                '9bZkp7q19f0', // PSY - GANGNAM STYLE
                'fJ9rUzIMcZQ', // Queen - Bohemian Rhapsody
                'L_jWHffIx5E', // Smells Like Teen Spirit - Nirvana
                'hTWKbfoikeg', // Smells Like Teen Spirit - Nirvana (다른 버전)
                'YlUKcNNmywk', // Red Hot Chili Peppers - Californication
                'v2AC41dglnM', // Charlie bit my finger
                'otCpCn0l4Wo', // David After Dentist
                'a1Y73sPHKxw', // Evolution of Dance
                'YQHsXMglC9A', // Hello - Adele (다른 버전)
                'kJQP7kiw5Fk', // Despacito (다른 버전)
                // 한국 동영상들
                '9bZkp7q19f0', // PSY - GANGNAM STYLE
                'BzYnNdJhZQw', // BTS - Dynamite
                'XsX3ATc3FbA', // BTS - Butter
                'g5qU7p7yOYc', // NewJeans - Attention
                'ArmDp-zijuc', // NewJeans - Hype Boy
                // Shorts들
                '2-s8dLibleg', // YouTube Shorts
                'dQw4w9WgXcQ', // Rick Roll (Shorts 버전)
                'jNQXAC9IVRw', // Me at the zoo (Shorts 버전)
                // 랜덤 인기 동영상들
                'kJQP7kiw5Fk', // Despacito
                'YQHsXMglC9A', // Hello - Adele
                '9bZkp7q19f0', // PSY - GANGNAM STYLE
                'fJ9rUzIMcZQ', // Queen - Bohemian Rhapsody
                'L_jWHffIx5E', // Smells Like Teen Spirit
                'hTWKbfoikeg', // Smells Like Teen Spirit (다른 버전)
                'YlUKcNNmywk', // Red Hot Chili Peppers
                'v2AC41dglnM', // Charlie bit my finger
                'otCpCn0l4Wo', // David After Dentist
                'a1Y73sPHKxw', // Evolution of Dance
                'BzYnNdJhZQw', // BTS - Dynamite
                'XsX3ATc3FbA', // BTS - Butter
                'g5qU7p7yOYc', // NewJeans - Attention
                'ArmDp-zijuc'  // NewJeans - Hype Boy
            ];
            
            // 랜덤하게 실제 비디오 ID 선택
            const randomIndex = Math.floor(Math.random() * realVideoIds.length);
            return realVideoIds[randomIndex];
        }

        // ===== Exclusion helpers =====
        function getExclusionRect(){
          const el = document.querySelector('.profile-gauge') || document.querySelector('.profile-image');
          if(!el) return null;
          const r = el.getBoundingClientRect();
          // 약간의 여유(패딩) 줌
          const pad = 8;
          return {
            left: Math.max(0, r.left - pad),
            top: Math.max(0, r.top - pad),
            right: Math.min(window.innerWidth, r.right + pad),
            bottom: Math.min(window.innerHeight, r.bottom + pad),
            width: Math.min(window.innerWidth, r.right + pad) - Math.max(0, r.left - pad),
            height: Math.min(window.innerHeight, r.bottom + pad) - Math.max(0, r.top - pad),
          };
        }

        function rectsOverlap(a, b){
          if(!a || !b) return false;
          return !(a.right <= b.left || a.left >= b.right || a.bottom <= b.top || a.top >= b.bottom);
        }

        // 주어진 사각형을 금지 구역 밖으로 가장 짧은 거리로 밀어내기
        function pushOutOfExclusion(winRect, exRect){
          // 겹치지 않으면 그대로
          if(!rectsOverlap(winRect, exRect)) return winRect;

          const pushLeft   = exRect.left - winRect.right;   // 왼쪽으로 밀기 (음수)
          const pushRight  = exRect.right - winRect.left;   // 오른쪽으로 밀기 (양수)
          const pushUp     = exRect.top - winRect.bottom;   // 위로 밀기 (음수)
          const pushDown   = exRect.bottom - winRect.top;   // 아래로 밀기 (양수)

          // 네 방향 중 |이동량|이 가장 작은 걸 선택
          const candidates = [
            {dx: pushLeft,  dy: 0,    dist: Math.abs(pushLeft)},
            {dx: pushRight, dy: 0,    dist: Math.abs(pushRight)},
            {dx: 0,         dy: pushUp,   dist: Math.abs(pushUp)},
            {dx: 0,         dy: pushDown, dist: Math.abs(pushDown)},
          ].sort((a,b)=>a.dist-b.dist);

          const best = candidates[0];
          return {
            left:   winRect.left + best.dx,
            top:    winRect.top  + best.dy,
            right:  winRect.right + best.dx,
            bottom: winRect.bottom + best.dy,
            width:  winRect.width,
            height: winRect.height
          };
        }

        function createRandomWindow(){
            const win = document.createElement('div');
            win.className = 'random-window';
            const w = 320, h = 180;

            const ex = getExclusionRect();

            // 겹치지 않는 랜덤 위치를 여러 번 시도
            let x = 0, y = 0;
            const margin = 12;
            const tries = 30;
            for(let i=0;i<tries;i++){
                x = Math.random() * (window.innerWidth - w);
                y = Math.random() * (window.innerHeight - h);

                const candidate = {left:x, top:y, right:x+w, bottom:y+h, width:w, height:h};
                if(!ex || !rectsOverlap(candidate, ex)){
                    break;
                }
                // 마지막 시도까지 겹치면 강제 재배치
                if(i === tries-1 && ex){
                    // 기본은 사이드(프로필 오른쪽)에 붙여 놓기
                    const prefX = Math.min(Math.max(ex.right + margin, 0), window.innerWidth - w);
                    const prefY = Math.min(Math.max(ex.top, 0), window.innerHeight - h);
                    x = prefX; y = prefY;
                }
            }

            win.style.cssText = `position:fixed!important;left:${x}px!important;top:${y}px!important;width:${w}px!important;height:${h}px!important;background:#fff!important;border:3px solid #000!important;z-index:9999!important;display:flex!important;align-items:center!important;justify-content:center!important;font-family:'Galmuri11',sans-serif!important;font-size:14px!important;color:#000!important;opacity:1!important;visibility:visible!important;cursor:move!important;padding:0!important;overflow:hidden!important;`;
            
            // 실제 유튜브 비디오 ID 선택
            const randomVideoId = getRandomYouTubeVideo();
            const youtubeUrl = `https://www.youtube.com/watch?v=${randomVideoId}`;
            
            // 팝업 내용 생성 - 썸네일 + 재생 버튼
            win.innerHTML = `
                <div style="position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center;">
                    <img src="https://img.youtube.com/vi/${randomVideoId}/mqdefault.jpg" 
                         style="width:100%; height:100%; object-fit:cover; cursor:pointer;" 
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <div style="display:none; flex-direction:column; align-items:center; justify-content:center; color:#666; font-size:12px; width:100%; height:100%; background:#f0f0f0;">
                        <div>📺</div>
                        <div>썸네일 없음</div>
                    </div>
                    <!-- 재생 버튼 오버레이 -->
                    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:60px; height:60px; background:rgba(0,0,0,0.8); border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:all 0.3s ease; z-index:10;" 
                         onmouseover="this.style.background='rgba(255,0,0,0.9)'; this.style.transform='translate(-50%, -50%) scale(1.1)'; this.style.boxShadow='0 0 20px rgba(255,0,0,0.5)'" 
                         onmouseout="this.style.background='rgba(0,0,0,0.8)'; this.style.transform='translate(-50%, -50%) scale(1)'; this.style.boxShadow='none'">
                        <div style="width:0; height:0; border-left:18px solid #fff; border-top:12px solid transparent; border-bottom:12px solid transparent; margin-left:4px;"></div>
                    </div>
                </div>
            `;
            
            // 클릭 이벤트 추가 (드래그 상태 체크)
            win.addEventListener('click', function(e) {
                // 드래그 상태가 아니고, 재생 버튼이나 이미지를 클릭한 경우에만 링크 열기
                if (!win.hasAttribute('data-dragged') && 
                    (e.target.tagName === 'IMG' || e.target.closest('[style*="position:absolute"]'))) {
                    window.open(youtubeUrl, '_blank');
                }
            });

            const btn = document.createElement('div');
            btn.className = 'close-button';
            btn.textContent = '×';
            btn.onclick = function(e) {
                e.stopPropagation();
                win.remove();

                // 기존 과부화 1% 감소 로직 유지
                const overloadPercentage = document.getElementById('overload-percentage');
                const progressFill = document.getElementById('progress-fill');
                if (overloadPercentage && progressFill) {
                    let currentPercent = parseInt(overloadPercentage.textContent) || 0;
                    currentPercent = Math.max(0, currentPercent - 1);
                    overloadPercentage.textContent = currentPercent;
                    progressFill.style.width = currentPercent + '%';
                }
                setTimeout(checkDetoxComplete, 0);
            };

            win.appendChild(btn);
            makeDraggable(win);
            document.body.appendChild(win);
        }
        
        function makeDraggable(element) {
            let isDragging = false;
            let hasDragged = false;
            let startX;
            let startY;
            let initialX;
            let initialY;
            let dragThreshold = 5; // 5px 이상 움직이면 드래그로 간주
            
            element.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
            
            function dragStart(e) {
                if (e.target.classList.contains('close-button')) {
                    return;
                }
                
                isDragging = true;
                hasDragged = false;
                
                initialX = parseInt(element.style.left) || 0;
                initialY = parseInt(element.style.top) || 0;
                
                startX = e.clientX;
                startY = e.clientY;
                
                e.preventDefault();
            }
            
            function drag(e) {
                if (!isDragging) return;
                e.preventDefault();

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                // 드래그 거리 체크
                const dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                if (dragDistance > dragThreshold) {
                    hasDragged = true;
                }

                let newX = initialX + deltaX;
                let newY = initialY + deltaY;

                // 화면 경계 안으로 클램프
                const rectNow = {
                  left: newX,
                  top: newY,
                  right: newX + element.offsetWidth,
                  bottom: newY + element.offsetHeight,
                  width: element.offsetWidth,
                  height: element.offsetHeight
                };

                // 프로필 게이지 금지 구역 회피
                const ex = getExclusionRect();
                let pushed = rectNow;
                if(ex && rectsOverlap(rectNow, ex)){
                  pushed = pushOutOfExclusion(rectNow, ex);
                }

                // 화면 경계 보정
                pushed.left = Math.min(Math.max(0, pushed.left), window.innerWidth - pushed.width);
                pushed.top  = Math.min(Math.max(0, pushed.top),  window.innerHeight - pushed.height);

                element.style.left = pushed.left + 'px';
                element.style.top  = pushed.top  + 'px';
            }
            
            function dragEnd(e) {
                isDragging = false;
                
                // 드래그했다면 클릭 이벤트 방지
                if (hasDragged) {
                    element.setAttribute('data-dragged', 'true');
                    // 잠시 후 드래그 상태 해제 (다음 클릭을 위해)
                    setTimeout(() => {
                        element.removeAttribute('data-dragged');
                    }, 100);
                }
            }
        }

        function startGlitchEffect(){
            isGlitching = true;
            document.querySelector('.explore-header').classList.add('glitch');
            setTimeout(()=>{
                document.querySelector('.explore-header').classList.remove('glitch');
                isGlitching = false;
            }, 1000);
        }
        
        function updateCleaningSwitchVisibility() {
            const switchElement = document.getElementById('cleaning-mode-switch');
            const overloadPercentage = document.getElementById('overload-percentage');
            if (!switchElement || !overloadPercentage) return;
            
            const docHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);
            const winHeight = window.innerHeight;
            const maxScroll = docHeight - winHeight;
            const progress = Math.min(scrollY / maxScroll, 1);
            
            let overloadPercent;
            if (isCleaningMode) {
                // 기준선 대비 청소 진행률 계산
                const cleaningProgress = getCleaningProgressRelative(); // 0~1
                overloadPercent = Math.round(cleaningModeStartPercent * (1 - cleaningProgress));
            } else {
                // 스크롤 모드에서는 현재 과부화 수치 유지 (감소하지 않음)
                const currentPercent = parseInt(document.getElementById('overload-percentage').textContent) || 0;
                overloadPercent = Math.max(currentPercent, Math.round(progress * 100));
            }
            
            // 과부화 퍼센트 업데이트 (숨겨진 요소)
            overloadPercentage.textContent = overloadPercent;
            
            // 프로필 과부화 표시도 업데이트
            updateProfileOverload(overloadPercent);
            
            if (scrollY > 0) {
                switchElement.classList.add('visible');
                switchElement.style.opacity = Math.max(0.1, progress);
                if (progress >= 0.95) {
                    switchElement.classList.add('active');
                    switchElement.style.backgroundColor = '#ff4444';
                    switchElement.style.color = '#fff';
                } else {
                    switchElement.classList.remove('active');
                    switchElement.style.backgroundColor = '#333';
                    switchElement.style.color = '#fff';
                }
            } else {
                switchElement.classList.remove('visible');
                switchElement.classList.remove('active');
                switchElement.style.backgroundColor = '#333';
                switchElement.style.color = '#fff';
            }
        }
        
        function toggleCleaningMode() {
            const docHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);
            const winHeight = window.innerHeight;
            const maxScroll = docHeight - winHeight;
            const progress = Math.min(scrollY / maxScroll, 1);
            console.log('클리닝 모드 클릭 - progress:', progress, 'scrollY:', scrollY, 'maxScroll:', maxScroll);
            if (progress < 0.95) {
                console.log('클리닝 모드 클릭 차단됨 - 95% 미만');
                return;
            }
            
            isCleaningMode = !isCleaningMode;
            const switchElement = document.getElementById('cleaning-mode-switch');
            const body = document.body;
            
            if(isCleaningMode) {
                switchElement.classList.add('active');
                switchElement.classList.remove('inactive');
                body.classList.add('cleaning-mode');
                switchElement.innerHTML = 'CLEANING<br>MODE ON';
                switchElement.style.backgroundColor = '#ff4444';
                switchElement.style.color = '#fff';
                
                // 진공청소기 효과음 재생
                playVacuumSound();
                
                // 클리닝 모드 시작 시점의 과부화 수치를 기준선으로 설정
                const currentPercent = parseInt(document.getElementById('overload-percentage').textContent) || 0;
                cleaningModeStartPercent = currentPercent;
                
                // 기준선 저장 (이미 사라진 썸네일들 제외)
                const originals = document.querySelectorAll('.explore-grid .thumbnail');
                baselineTotalThumbs = originals.length;
                baselineCleanedThumbs = Array.from(originals).filter(thumb =>
                    thumb.classList.contains('destroyed') ||
                    thumb.classList.contains('already-fallen') ||
                    thumb.style.visibility === 'hidden'
                ).length;
                
                
                
                document.querySelectorAll('.thumbnail.falling').forEach(fallingThumbnail => {
                    fallingThumbnail.style.pointerEvents = 'auto';
                });
            } else {
                switchElement.classList.remove('active');
                switchElement.classList.add('inactive');
                body.classList.remove('cleaning-mode');
                switchElement.innerHTML = 'CLEANING<br>MODE';
                switchElement.style.backgroundColor = '#666';
                switchElement.style.color = '#ccc';
                
                // 진공청소기 소리 정지
                stopVacuumSound();
                
                // 기준선 초기화
                baselineTotalThumbs = 0;
                baselineCleanedThumbs = 0;
                
                
                
                document.querySelectorAll('.thumbnail.falling').forEach(fallingThumbnail => {
                    fallingThumbnail.style.pointerEvents = 'none';
                });
            }
        }
        
        // 진공청소기 효과음 재생 함수
        let vacuumAudio = null; // 전역 변수로 오디오 객체 저장
        
        function playVacuumSound() {
            try {
                // 기존 오디오가 있으면 정지
                if (vacuumAudio) {
                    vacuumAudio.pause();
                    vacuumAudio.currentTime = 0;
                }
                
                vacuumAudio = new Audio('Vsound.m4a');
                vacuumAudio.volume = 0.7; // 볼륨 조절 (0.0 ~ 1.0)
                vacuumAudio.loop = true; // 반복 재생
                vacuumAudio.play().catch(error => {
                    console.log('효과음 재생 실패:', error);
                });
            } catch (error) {
                console.log('오디오 파일 로드 실패:', error);
            }
        }
        
        function stopVacuumSound() {
            if (vacuumAudio) {
                vacuumAudio.pause();
                vacuumAudio.currentTime = 0;
                console.log('진공청소기 소리 정지');
            }
        }
        
        function playOffSound() {
            try {
                const offAudio = new Audio('Offsound.m4a');
                offAudio.volume = 0.7; // 볼륨 조절 (0.0 ~ 1.0)
                offAudio.play().catch(error => {
                    console.log('종료 효과음 재생 실패:', error);
                });
                
                // 오프사운드 재생 시 진공청소기 소리 정지
                stopVacuumSound();
                console.log('오프사운드 재생으로 인한 진공청소기 소리 정지');
            } catch (error) {
                console.log('종료 오디오 파일 로드 실패:', error);
            }
        }
        
        function cleanElement(element) {
            if(element.classList.contains('thumbnail')) {
                if(element.classList.contains('falling')) {
                    fallingThumbnails = fallingThumbnails.filter(obj => obj.element !== element);
                }
                element.classList.add('destroyed');
                destroyedCount++;
            } else if(element.tagName === 'A' && element.closest('.menu')) {
                element.classList.add('cleaned');
                
                setTimeout(() => {
                    checkSidebarVisibility();
                }, 100);
            } else if(element.classList.contains('search')) {
                console.log('검색창 클리닝:', element);
                element.classList.add('cleaned');
                console.log('검색창 cleaned 클래스 추가됨:', element.classList.contains('cleaned'));
                
                // 헤더 배경까지 지우기
                const header = document.querySelector('.explore-header');
                if (header && !header.classList.contains('cleaned')) {
                    header.classList.add('cleaned');
                }
                return;
            } else if(element.classList.contains('brand') && element.closest('.sidebar')) {
                element.classList.add('cleaned');
                
                setTimeout(() => {
                    checkSidebarVisibility();
                }, 100);
            } else if(element.classList.contains('profile-section') || element.classList.contains('profile-image') || element.classList.contains('profile-name') || element.classList.contains('profile-gauge') || element.classList.contains('profile-stats') || element.classList.contains('profile-bio')) {
                element.classList.add('cleaned');
                
                setTimeout(() => {
                    checkSidebarVisibility();
                }, 100);
            } else if(element.classList.contains('sidebar')) {
                element.classList.add('cleaned');
                return;
            } else if(element.classList.contains('random-window')) {
                element.classList.add('cleaned');
            } else if(element.classList.contains('cleaning-mode-switch')) {
                element.classList.add('cleaned');
                return;
            } else if(element.classList.contains('detox-complete') && element.classList.contains('cleanable')) {
                // 디톡스 컴플리트 텍스트는 3초 후에만 삭제 가능
                element.classList.add('cleaned');
                element.style.opacity = '0';
                return;
            }
            
            element.style.setProperty('visibility', 'hidden', 'important');
            element.style.pointerEvents = 'none';
            
            createGhostAndAnimate(element);
            
            setTimeout(() => {
                checkDetoxComplete();
                // 클리닝 모드에서 썸네일 지울 때 과부화 수치 즉시 업데이트
                if (isCleaningMode && element.classList.contains('thumbnail')) {
                    const cleaningProgress = getCleaningProgressRelative();
                    const overloadPercent = Math.round(cleaningModeStartPercent * (1 - cleaningProgress));
                    
                    const overloadPercentage = document.getElementById('overload-percentage');
                    const progressFill = document.getElementById('progress-fill');
                    if (overloadPercentage && progressFill) {
                        overloadPercentage.textContent = overloadPercent;
                        progressFill.style.width = overloadPercent + '%';
                    }
                    
                    // 프로필 과부화 표시도 업데이트
                    updateProfileOverload(overloadPercent);
                } else {
                    updateCleaningSwitchVisibility();
                }
            }, 200);
        }
        
        function checkSidebarVisibility() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar || sidebar.classList.contains('cleaned')) return;
            
            // 메뉴 링크들과 프로필 섹션만 확인
            const menuLinks = sidebar.querySelectorAll('.menu a');
            const profileSection = sidebar.querySelector('.profile-section');
            
            console.log('메뉴 링크 개수:', menuLinks.length);
            console.log('프로필 섹션:', profileSection);
            
            const allMenuLinksCleaned = Array.from(menuLinks).every(link => {
                const isCleaned = link.classList.contains('cleaned') || link.classList.contains('destroyed');
                console.log('메뉴 링크:', link.textContent, 'cleaned:', isCleaned);
                return isCleaned;
            });
            
            const profileCleaned = profileSection ? 
                (profileSection.classList.contains('cleaned') || profileSection.classList.contains('destroyed')) : true;
            
            console.log('모든 메뉴 링크 지워짐:', allMenuLinksCleaned);
            console.log('프로필 섹션 지워짐:', profileCleaned);
            
            if (allMenuLinksCleaned && profileCleaned) {
                console.log('사이드바 사라짐!');
                sidebar.classList.add('cleaned');
            }
        }
        
        function checkDetoxComplete() {
            // 이미 완료된 경우 중복 실행 방지
            if (detoxComplete) return;
            
            const originalThumbnails = document.querySelectorAll('.explore-grid .thumbnail');
            const cleanedThumbnails = Array.from(originalThumbnails).filter(thumb => 
                thumb.classList.contains('destroyed') || 
                thumb.classList.contains('already-fallen') ||
                thumb.style.visibility === 'hidden'
            );
            const thumbnailPercentage = originalThumbnails.length > 0 ? 
                (cleanedThumbnails.length / originalThumbnails.length) * 100 : 100;
            const thumbnails95PercentGone = thumbnailPercentage >= 75;
            
            const sidebar = document.querySelector('.sidebar');
            const sidebarGone = !sidebar || sidebar.classList.contains('cleaned');
            
            const allWindows = document.querySelectorAll('.random-window');
            const cleanedWindows = Array.from(allWindows).filter(window => 
                window.classList.contains('cleaned') ||
                window.style.visibility === 'hidden'
            );
            const windowsPercentage = allWindows.length > 0 ? (cleanedWindows.length / allWindows.length) * 100 : 100;
            const allWindowsGone = windowsPercentage >= 50;
            
            console.log('DETOX 체크 (75% 이상):', {
                썸네일사라진비율: `${thumbnailPercentage.toFixed(1)}%`,
                썸네일75퍼센트이상: thumbnails95PercentGone,
                좌측메뉴: sidebarGone,
                팝업창80퍼센트이상: allWindowsGone,
                팝업창사라진비율: `${windowsPercentage.toFixed(1)}%`
            });
            
            if (thumbnails95PercentGone && sidebarGone && allWindowsGone) {
                detoxComplete = true; // 완료 플래그 설정
                
                setTimeout(() => {
                    const detoxMessage = document.getElementById('detox-complete');
                    if (detoxMessage) {
                        detoxMessage.classList.add('visible');
                        
                        // 3초 후에 클리닝 모드에서 삭제 가능하도록 클래스 추가
                        setTimeout(() => {
                            detoxMessage.classList.add('cleanable');
                        }, 3000);
                    }
                    
                    // 청소 완료 시 오프사운드만 재생 (진공청소기 소리는 계속 유지)
                    playOffSound();
                }, 1000);
            }
        }
        
        function createGhostAndAnimate(originalElement) {
            const ghost = originalElement.cloneNode(true);
            
            ghost.classList.remove('destroyed', 'cleaned');
            
            const rect = originalElement.getBoundingClientRect();
            const computedStyle = getComputedStyle(originalElement);
            
            ghost.style.cssText = `
                position: fixed !important;
                left: ${rect.left}px !important;
                top: ${rect.top}px !important;
                width: ${rect.width}px !important;
                height: ${rect.height}px !important;
                z-index: 10000 !important;
                pointer-events: none !important;
                transform: none !important;
                opacity: 1 !important;
                animation: none !important;
                background: ${computedStyle.background} !important;
                border: ${computedStyle.border} !important;
                border-radius: ${computedStyle.borderRadius} !important;
                padding: ${computedStyle.padding} !important;
                margin: ${computedStyle.margin} !important;
                display: ${computedStyle.display} !important;
                align-items: ${computedStyle.alignItems} !important;
                justify-content: ${computedStyle.justifyContent} !important;
                gap: ${computedStyle.gap} !important;
                color: ${computedStyle.color} !important;
                font-family: ${computedStyle.fontFamily} !important;
                font-size: ${computedStyle.fontSize} !important;
                font-weight: ${computedStyle.fontWeight} !important;
                text-decoration: ${computedStyle.textDecoration} !important;
            `;
            
            document.body.appendChild(ghost);
            
            animateGhostToMouse(ghost, originalElement);
        }
        
        function animateGhostToMouse(ghost, originalElement) {
            const startTime = Date.now();
            const duration = 2000;
            
            const rect = originalElement.getBoundingClientRect();
            const startX = rect.left;
            const startY = rect.top;
            const startScale = 1;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const mouseX = window.mouseX || 0;
                const mouseY = window.mouseY || 0;
                
                const easeInOut = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                const currentX = startX + (mouseX - startX) * easeInOut;
                const currentY = startY + (mouseY - startY) * easeInOut;
                
                const currentScale = startScale * (1 - easeInOut * 0.9);
                
                const currentOpacity = 1 - easeInOut;
                
                ghost.style.left = currentX + 'px';
                ghost.style.top = currentY + 'px';
                ghost.style.transform = `scale(${currentScale})`;
                ghost.style.opacity = currentOpacity;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    if(ghost.parentNode) {
                        ghost.remove();
                    }
                }
            }
            
            requestAnimationFrame(animate);
        }


        // 간단한 하단-바닥 충돌 + 감쇠만 적용(서로 충돌 제거로 튐 방지)
        function updateFallingThumbnails(){
            for(const t of fallingThumbnails){
                if(t.isStacked) continue;

                t.velocityY += GRAVITY;

                t.velocityX *= FRICTION;
                t.velocityY *= FRICTION;
                t.rotationSpeed *= FRICTION;

                t.velocityX = clamp(t.velocityX, -MAX_SPEED, MAX_SPEED);
                t.velocityY = clamp(t.velocityY, -MAX_SPEED, MAX_SPEED);

                t.x += t.velocityX;
                t.y += t.velocityY;

                t.rotation += t.rotationSpeed;

                if(t.x < 0){
                    t.x = 0;
                    t.velocityX = Math.abs(t.velocityX);
                }
                if(t.x + t.width > window.innerWidth){
                    t.x = window.innerWidth - t.width;
                    t.velocityX = -Math.abs(t.velocityX);
                }

                const localPile = getLocalPileHeight(t.x, t.width);
                const floorY = window.innerHeight - t.height - Math.max(pileHeight, localPile);
                if(t.y > floorY){
                    t.y = floorY;
                    t.velocityY = -t.velocityY * BOUNCE;
                    t.velocityX = (t.velocityX * 0.6) + (t.rollBias * 0.4);

                    if(Math.abs(t.velocityY) < MIN_VELOCITY && Math.abs(t.velocityX) < MIN_VELOCITY){
                        t.isStacked = true;
                        t.element.classList.remove('falling');
                        t.element.style.pointerEvents = 'auto';
                        t.element.style.zIndex = '5';
                        t.x += (Math.random()*2 - 1) * SETTLE_X_JITTER;
                        t.element.style.transform = 'rotate(0deg)';
                        stackedThumbnails.push(t);
                        pileHeight = Math.min(window.innerHeight * PILE_CAP, pileHeight + t.height * (PILE_GROWTH * 0.5));
                    }
                }

                t.element.style.left = t.x + 'px';
                t.element.style.top  = t.y + 'px';
                t.element.style.transform = `rotate(${t.rotation}deg)`;
            }

            fallingThumbnails = fallingThumbnails.filter(t => !t.isStacked);
        }

        function animate(){
            updateFallingThumbnails();
            requestAnimationFrame(animate);
        }

        // 얼굴 랜드마크 관련 변수
        let faceMesh = null;
        let lastFaceLandmarks = null;
        let camera = null;
        let isDrawing = false;
        let lastFrameTime = 0;
        const TARGET_FPS = 30; // 60fps에서 30fps로 제한
        const FRAME_INTERVAL = 1000 / TARGET_FPS;

        // 웹캠 초기화 함수 (얼굴 랜드마크 + 픽셀레이션 효과 포함)
        function initWebcam() {
            const video = document.getElementById('profile-video');
            const canvas = document.getElementById('profile-canvas');
            if (!video || !canvas) return;

            const context = canvas.getContext('2d', { willReadFrequently: true });
            const constraints = {
                video: { 
                    facingMode: "user",
                    width: { ideal: 640 },
                    height: { ideal: 640 }
                }, 
                audio: false
            };

            // MediaPipe Face Mesh 초기화
            initFaceMesh().then(() => {
                navigator.mediaDevices.getUserMedia(constraints)
                    .then(function(stream) {
                        video.srcObject = stream;
                        video.play();
                        
                        // Camera Utils로 프레임 동기화
                        camera = new Camera(video, {
                            onFrame: async () => {
                                if (faceMesh && !isDrawing) {
                                    try {
                                        await faceMesh.send({ image: video });
                                    } catch (error) {
                                        console.log('FaceMesh send 오류:', error);
                                    }
                                }
                            },
                            width: 640,
                            height: 640
                        });
                        camera.start();
                        
                        // 그리기 루프 시작
                        startDrawingLoop(context, video, canvas);
                    })
                    .catch(function(error) {
                        console.log('웹캠 접근 오류:', error);
                        // 웹캠이 없거나 거부된 경우 기본 이미지로 대체
                        const profileImage = document.querySelector('.profile-image');
                        if (profileImage) {
                            profileImage.innerHTML = '<img src="profile.jpg" alt="프로필" />';
                        }
                    });
            }).catch(error => {
                console.log('얼굴 랜드마크 초기화 오류:', error);
                // 얼굴 랜드마크 실패 시 기본 픽셀레이션으로 폴백
                navigator.mediaDevices.getUserMedia(constraints)
                    .then(function(stream) {
                        video.srcObject = stream;
                        video.play();
                        drawPixelatedVideo(context, video, canvas);
                    })
                    .catch(function(error) {
                        console.log('웹캠 접근 오류:', error);
                        const profileImage = document.querySelector('.profile-image');
                        if (profileImage) {
                            profileImage.innerHTML = '<img src="profile.jpg" alt="프로필" />';
                        }
                    });
            });
        }

        // MediaPipe Face Mesh 초기화
        async function initFaceMesh() {
            const faceMeshModule = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });

            faceMeshModule.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMeshModule.onResults(onFaceMeshResults);
            faceMesh = faceMeshModule;
        }

        // 얼굴 랜드마크 결과 처리
        function onFaceMeshResults(results) {
            lastFaceLandmarks = results;
            if (results && results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                console.log('얼굴 랜드마크 감지됨:', results.multiFaceLandmarks.length + '개 얼굴');
            }
        }

        // 그리기 루프 시작 (rAF에서는 그리기만)
        function startDrawingLoop(ctx, video, canvas) {
            const pixelSize = 8;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            function draw(currentTime) {
                if (isDrawing) return;
                
                // 프레임 레이트 제한
                if (currentTime - lastFrameTime < FRAME_INTERVAL) {
                    requestAnimationFrame(draw);
                    return;
                }
                
                isDrawing = true;
                lastFrameTime = currentTime;
                
                // 비디오를 캔버스에 그리기
                ctx.drawImage(video, 0, 0, canvasWidth, canvasHeight);
                
                // 픽셀레이션 적용
                pixelateCanvas(ctx, pixelSize);
                
                // 얼굴 랜드마크 및 뇌 영역 강조
                if (lastFaceLandmarks && lastFaceLandmarks.multiFaceLandmarks && lastFaceLandmarks.multiFaceLandmarks.length > 0) {
                    highlightBrainArea(ctx, lastFaceLandmarks.multiFaceLandmarks[0], canvasWidth, canvasHeight);
                    
                    // 얼굴 특징점을 도트로 표시
                    drawFacialDots(ctx, lastFaceLandmarks.multiFaceLandmarks[0], canvasWidth, canvasHeight);
                } else {
                    // 얼굴이 인식되지 않으면 기본 색상 필터 적용
                    applyColorFilter(ctx, canvasWidth, canvasHeight);
                }
                
                isDrawing = false;
                requestAnimationFrame(draw);
            }
            
            draw();
        }

        // 뇌 영역 강조 함수 (헬멧 모양)
        function highlightBrainArea(ctx, landmarks, canvasWidth, canvasHeight) {
            // 배경을 하얗게 설정
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            if (landmarks && landmarks.length > 0) {
                // 얼굴 영역을 정의하는 랜드마크 포인트들 (얼굴 전체)
                const faceLandmarks = [10, 151, 9, 8, 107, 55, 65, 52, 53, 46, 70, 63, 105, 66, 69,
                                      172, 136, 150, 149, 176, 148, 152, 377, 400, 378, 379, 365, 397, 288, 361, 323,
                                      454, 356, 389, 251, 284, 332, 297, 338, 10, 151, 9, 8, 107, 55, 65, 52, 53, 46, 70, 63, 105, 66, 69];
                
                // 얼굴 영역의 경계점들 찾기
                const facePoints = faceLandmarks.map(index => {
                    if (index < landmarks.length) {
                        const landmark = landmarks[index];
                        return {
                            x: landmark.x * canvasWidth,
                            y: landmark.y * canvasHeight
                        };
                    }
                    return null;
                }).filter(point => point !== null);

                if (facePoints.length > 0) {
                    // 얼굴 영역을 회색톤으로 그리기
                    applyFaceColorFilter(ctx, facePoints, canvasWidth, canvasHeight);
                    
                    // 헬멧 모양의 뇌 영역을 위한 랜드마크 포인트들
                    const foreheadLandmarks = [10, 151, 9, 8, 107, 55, 65, 52, 53, 46, 70, 63, 105, 66, 69];
                    
                    // 이마 영역의 경계점들 찾기
                    const foreheadPoints = foreheadLandmarks.map(index => {
                        if (index < landmarks.length) {
                            const landmark = landmarks[index];
                            return {
                                x: landmark.x * canvasWidth,
                                y: landmark.y * canvasHeight
                            };
                        }
                        return null;
                    }).filter(point => point !== null);

                    if (foreheadPoints.length > 0) {
                        // 이마 영역의 중심점과 크기 계산
                        const centerX = foreheadPoints.reduce((sum, p) => sum + p.x, 0) / foreheadPoints.length;
                        const centerY = foreheadPoints.reduce((sum, p) => sum + p.y, 0) / foreheadPoints.length;
                        
                        // 이마 영역의 최대/최소 좌표 계산
                        const minX = Math.min(...foreheadPoints.map(p => p.x));
                        const maxX = Math.max(...foreheadPoints.map(p => p.x));
                        const minY = Math.min(...foreheadPoints.map(p => p.y));
                        const maxY = Math.max(...foreheadPoints.map(p => p.y));
                        
                        const width = maxX - minX;
                        const height = maxY - minY;
                        
                        // 헬멧 모양의 뇌 영역 생성 (얼굴을 벗어나지 않도록)
                        const helmetPoints = createHelmetShape(centerX, centerY, width, height, canvasWidth, canvasHeight);
                        
                        // 뇌 영역을 과부화 퍼센트에 따라 점진적 픽셀 변화 (픽셀 효과 포함)
                        const pixelSize = 8;
                        const overloadPercentage = parseInt(document.getElementById('overload-percentage').textContent) || 0;
                        
                        // 뇌 영역 내의 모든 픽셀 위치를 수집
                        const brainPixels = [];
                        for (let px = 0; px < canvasWidth; px += pixelSize) {
                            for (let py = 0; py < canvasHeight; py += pixelSize) {
                                // 뇌 영역 내부인지 확인
                                if (isPointInPolygon(px + pixelSize/2, py + pixelSize/2, helmetPoints)) {
                                    brainPixels.push({ x: px, y: py });
                                }
                            }
                        }
                        
                        // 뇌 영역을 픽셀로 그리기 (과부화 퍼센트에 따라 랜덤하게 빨간색으로 변화)
                        brainPixels.forEach((pixel) => {
                            // 각 픽셀의 고유한 시드를 생성 (위치 기반)
                            const seed = pixel.x * 10000 + pixel.y;
                            
                            // 시드를 기반으로 0-1 사이의 랜덤 값 생성
                            let randomValue = (Math.sin(seed) * 10000) % 1;
                            if (randomValue < 0) randomValue = -randomValue; // 음수 방지
                            
                            // 과부화 퍼센트에 따라 빨간 픽셀 확률 결정
                            const redProbability = overloadPercentage / 100;
                            
                            if (randomValue < redProbability) {
                                // 빨간색 픽셀
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
                            } else {
                                // 파란색 픽셀
                                ctx.fillStyle = 'rgba(0, 0, 255, 0.9)';
                            }
                            ctx.fillRect(pixel.x, pixel.y, pixelSize, pixelSize);
                        });

                        // 뇌 영역 경계선도 과부화에 따라 색상 변화
                        for (let px = 0; px < canvasWidth; px += pixelSize) {
                            for (let py = 0; py < canvasHeight; py += pixelSize) {
                                // 경계선 근처인지 확인
                                const isNearBoundary = isNearPolygonBoundary(px + pixelSize/2, py + pixelSize/2, helmetPoints, pixelSize * 1.5);
                                if (isNearBoundary) {
                                    // 경계선도 동일한 랜덤 방식으로 색상 변화
                                    const seed = px * 10000 + py;
                                    let randomValue = (Math.sin(seed) * 10000) % 1;
                                    if (randomValue < 0) randomValue = -randomValue; // 음수 방지
                                    const redProbability = overloadPercentage / 100;
                                    
                                    if (randomValue < redProbability) {
                                        ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                                    } else {
                                        ctx.fillStyle = 'rgba(100, 100, 255, 0.8)';
                                    }
                                    ctx.fillRect(px, py, pixelSize, pixelSize);
                                }
                            }
                        }
                    }
                }
            } else {
                // 얼굴이 인식되지 않으면 전체를 회색톤으로
                applyColorFilter(ctx, canvasWidth, canvasHeight);
            }
        }

        // 얼굴 특징점을 도트로 표시
        function drawFacialDots(ctx, landmarks, w, h) {
            // 픽셀 사이즈와 동일하게 설정
            const pixelSize = 8;
            
            // 검은색으로 그리기
            ctx.fillStyle = '#000000';
            
            // 눈 그리기 (타원형)
            const leftEyeCenter = {
                x: Math.round(landmarks[33].x * w),
                y: Math.round(landmarks[33].y * h)
            };
            const rightEyeCenter = {
                x: Math.round(landmarks[362].x * w),
                y: Math.round(landmarks[362].y * h)
            };
            
            // 눈 크기 (픽셀 사이즈 기준)
            const eyeWidth = pixelSize * 2; // 16px
            const eyeHeight = pixelSize; // 8px
            
            // 왼쪽 눈 그리기 (흰자 + 검은자)
            // 흰자
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(leftEyeCenter.x - eyeWidth/2, leftEyeCenter.y - eyeHeight/2, eyeWidth, eyeHeight);
            
            // 검은자 (중앙에 작은 네모)
            ctx.fillStyle = '#000000';
            const pupilSize = pixelSize * 0.75; // 6px
            ctx.fillRect(leftEyeCenter.x - pupilSize/2, leftEyeCenter.y - pupilSize/2, pupilSize, pupilSize);
            
            // 오른쪽 눈 그리기 (흰자 + 검은자) - 살짝 아래로
            const rightEyeOffset = pixelSize * 0.5; // 4px 아래로
            const rightEyeY = rightEyeCenter.y + rightEyeOffset;
            
            // 흰자
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(rightEyeCenter.x - eyeWidth/2, rightEyeY - eyeHeight/2, eyeWidth, eyeHeight);
            
            // 검은자 (중앙에 작은 네모)
            ctx.fillStyle = '#000000';
            ctx.fillRect(rightEyeCenter.x - pupilSize/2, rightEyeY - pupilSize/2, pupilSize, pupilSize);
            
            // 코 그리기 (세로 직사각형)
            const noseTip = {
                x: Math.round(landmarks[1].x * w),
                y: Math.round(landmarks[1].y * h)
            };
            const noseWidth = pixelSize * 0.75; // 6px
            const noseHeight = pixelSize * 2; // 16px
            ctx.fillStyle = '#000000';
            ctx.fillRect(noseTip.x - noseWidth/2, noseTip.y - noseHeight/2, noseWidth, noseHeight);
            
            // 입 그리기 (가로 직사각형)
            const mouthCenter = {
                x: Math.round((landmarks[13].x + landmarks[14].x) / 2 * w),
                y: Math.round((landmarks[13].y + landmarks[14].y) / 2 * h)
            };
            const mouthWidth = pixelSize * 2; // 16px
            const mouthHeight = pixelSize * 0.5; // 4px
            ctx.fillRect(mouthCenter.x - mouthWidth/2, mouthCenter.y - mouthHeight/2, mouthWidth, mouthHeight);
        }

        // 얼굴 영역만 회색톤으로 변환하는 함수 (이목구비 보이게)
        function applyFaceColorFilter(ctx, facePoints, canvasWidth, canvasHeight) {
            const pixelSize = 8;
            
            // 얼굴 영역의 경계를 계산
            const minX = Math.min(...facePoints.map(p => p.x));
            const maxX = Math.max(...facePoints.map(p => p.x));
            const minY = Math.min(...facePoints.map(p => p.y));
            const maxY = Math.max(...facePoints.map(p => p.y));
            
            // 얼굴 영역을 약간 확장
            const padding = 20;
            const faceMinX = Math.max(0, minX - padding);
            const faceMaxX = Math.min(canvasWidth, maxX + padding);
            const faceMinY = Math.max(0, minY - padding);
            const faceMaxY = Math.min(canvasHeight, maxY + padding);
            
            // 얼굴 영역을 타원형으로 근사하여 회색톤 적용
            const centerX = (faceMinX + faceMaxX) / 2;
            const centerY = (faceMinY + faceMaxY) / 2;
            const radiusX = (faceMaxX - faceMinX) / 2;
            const radiusY = (faceMaxY - faceMinY) / 2;
            
            for (let px = 0; px < canvasWidth; px += pixelSize) {
                for (let py = 0; py < canvasHeight; py += pixelSize) {
                    // 타원 내부인지 확인
                    const dx = (px + pixelSize/2 - centerX) / radiusX;
                    const dy = (py + pixelSize/2 - centerY) / radiusY;
                    const isInEllipse = (dx * dx + dy * dy) <= 1;
                    
                    if (isInEllipse) {
                        // 원본 이미지의 밝기를 기반으로 회색톤 결정
                        const imageData = ctx.getImageData(px, py, pixelSize, pixelSize);
                        const data = imageData.data;
                        let totalBrightness = 0;
                        let pixelCount = 0;
                        
                        for (let i = 0; i < data.length; i += 4) {
                            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            totalBrightness += brightness;
                            pixelCount++;
                        }
                        
                        const avgBrightness = totalBrightness / pixelCount;
                        
                        // 밝기에 따라 4단계 회색톤으로 변환 (이목구비 구분)
                        let grayValue;
                        if (avgBrightness < 50) {
                            grayValue = 30; // 매우 어두운 회색 (눈, 입 등)
                        } else if (avgBrightness < 100) {
                            grayValue = 60; // 어두운 회색 (그림자 부분)
                        } else if (avgBrightness < 150) {
                            grayValue = 100; // 중간 어두운 회색 (코, 볼 등)
                        } else if (avgBrightness < 200) {
                            grayValue = 140; // 중간 회색 (이마, 볼 등)
                        } else {
                            grayValue = 180; // 밝은 회색 (이마, 볼의 밝은 부분)
                        }
                        
                        ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
                        ctx.fillRect(px, py, pixelSize, pixelSize);
                    }
                }
            }
        }

        // 과부화 퍼센트에 따른 뇌 색상 계산 함수
        function calculateBrainColor(percentage) {
            // 0% = 파란색, 100% = 빨간색으로 점진적 변화
            const normalizedPercent = Math.max(0, Math.min(100, percentage)) / 100;
            
            // 파란색 (0, 0, 255)에서 빨간색 (255, 0, 0)으로 선형 보간
            const r = Math.round(255 * normalizedPercent);
            const g = 0;
            const b = Math.round(255 * (1 - normalizedPercent));
            
            return { r, g, b };
        }

        // 헬멧 모양의 뇌 영역 생성
        function createHelmetShape(centerX, centerY, width, height, canvasWidth, canvasHeight) {
            const points = [];
            const numPoints = 16; // 헬멧의 둥근 모양을 위한 포인트 수
            
            // 헬멧의 크기 조정 (얼굴을 벗어나지 않도록)
            const helmetWidth = Math.min(width * 1.5, canvasWidth * 0.85);
            const helmetHeight = Math.min(height * 1.4, canvasHeight * 0.65);
            
            // 헬멧의 상단 반원 부분
            for (let i = 0; i < numPoints / 2; i++) {
                const angle = Math.PI + (i * Math.PI) / (numPoints / 2 - 1);
                const x = centerX + (helmetWidth / 2) * Math.cos(angle);
                const y = centerY - helmetHeight / 3 + (helmetHeight / 3) * Math.sin(angle);
                points.push({ x, y });
            }
            
            // 헬멧의 하단 직선 부분 (이마 라인)
            const bottomY = centerY + helmetHeight / 4;
            const leftX = centerX - helmetWidth / 2;
            const rightX = centerX + helmetWidth / 2;
            
            points.push({ x: rightX, y: bottomY });
            points.push({ x: leftX, y: bottomY });
            
            // 캔버스 경계 내로 제한
            return points.map(point => ({
                x: Math.max(0, Math.min(canvasWidth, point.x)),
                y: Math.max(0, Math.min(canvasHeight, point.y))
            }));
        }

        // 점이 다각형 경계 근처에 있는지 확인하는 함수
        function isNearPolygonBoundary(x, y, polygon, threshold) {
            let minDistance = Infinity;
            
            for (let i = 0; i < polygon.length; i++) {
                const j = (i + 1) % polygon.length;
                const distance = pointToLineDistance(x, y, polygon[i].x, polygon[i].y, polygon[j].x, polygon[j].y);
                minDistance = Math.min(minDistance, distance);
            }
            
            return minDistance <= threshold;
        }

        // 점에서 선분까지의 최단 거리 계산
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) {
                param = dot / lenSq;
            }

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // 점이 다각형 내부에 있는지 확인하는 함수
        function isPointInPolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > y) !== (polygon[j].y > y)) &&
                    (x < (polygon[j].x - polygon[i].x) * (y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // 픽셀레이션 비디오 그리기 함수
        // 메모리 정리 함수
        function cleanupProfileMemory() {
            if (pixelCanvas) {
                pixelCanvas = null;
                pixelCtx = null;
            }
            lastFrameTime = 0;
        }

        // 픽셀레이션 함수
        // 픽셀레이션 함수 (메모리 최적화)
        let pixelCanvas = null;
        let pixelCtx = null;
        
        function pixelateCanvas(ctx, pixelSize) {
            const canvasWidth = ctx.canvas.width;
            const canvasHeight = ctx.canvas.height;

            // 캔버스 재사용 (매번 새로 생성하지 않음)
            if (!pixelCanvas || pixelCanvas.width !== canvasWidth || pixelCanvas.height !== canvasHeight) {
                pixelCanvas = document.createElement('canvas');
                pixelCanvas.width = canvasWidth;
                pixelCanvas.height = canvasHeight;
                pixelCtx = pixelCanvas.getContext('2d', { willReadFrequently: true });
                
                // 이미지 스무딩 비활성화 (한 번만 설정)
                pixelCtx.imageSmoothingEnabled = false;
                pixelCtx.mozImageSmoothingEnabled = false;
                pixelCtx.webkitImageSmoothingEnabled = false;
                pixelCtx.msImageSmoothingEnabled = false;
            }

            pixelCtx.drawImage(ctx.canvas, 0, 0);

            // 픽셀 데이터를 한 번에 가져와서 처리
            const imageData = pixelCtx.getImageData(0, 0, canvasWidth, canvasHeight);
            const data = imageData.data;

            for (let x = 0; x < canvasWidth; x += pixelSize) {
                for (let y = 0; y < canvasHeight; y += pixelSize) {
                    let r = 0, g = 0, b = 0, a = 0;
                    let count = 0;

                    // 픽셀 블록의 평균 색상 계산
                    for (let px = x; px < x + pixelSize && px < canvasWidth; px++) {
                        for (let py = y; py < y + pixelSize && py < canvasHeight; py++) {
                            const index = (py * canvasWidth + px) * 4;
                            r += data[index];
                            g += data[index + 1];
                            b += data[index + 2];
                            a += data[index + 3];
                            count++;
                        }
                    }

                    const avgR = Math.round(r / count);
                    const avgG = Math.round(g / count);
                    const avgB = Math.round(b / count);
                    const avgA = Math.round(a / count);

                    // 픽셀 블록에 평균 색상 적용
                    for (let px = x; px < x + pixelSize && px < canvasWidth; px++) {
                        for (let py = y; py < y + pixelSize && py < canvasHeight; py++) {
                            const index = (py * canvasWidth + px) * 4;
                            data[index] = avgR;
                            data[index + 1] = avgG;
                            data[index + 2] = avgB;
                            data[index + 3] = avgA;
                        }
                    }
                }
            }

            pixelCtx.putImageData(imageData, 0, 0);
            ctx.drawImage(pixelCanvas, 0, 0);
        }

        // 평균 색상 계산 함수
        function getAverageColor(pixelData) {
            const data = pixelData.data;
            let r = 0, g = 0, b = 0, a = 0;

            for (let i = 0; i < data.length; i += 4) {
                r += data[i];
                g += data[i + 1];
                b += data[i + 2];
                a += data[i + 3];
            }

            const numPixels = data.length / 4;
            return {
                r: Math.round(r / numPixels),
                g: Math.round(g / numPixels),
                b: Math.round(b / numPixels),
                a: Math.round(a / numPixels)
            };
        }

        // 색상 필터 적용 함수 (4개 무채색 톤으로 변환)
        function applyColorFilter(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const toData = new Uint8ClampedArray(data.length);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let pos = (width * y * 4) + (x * 4);
                    let avr = data[pos] + data[pos + 1] + data[pos + 2];
                    
                    // 밝기에 따라 4개 무채색 톤으로 변환
                    let grayValue = Math.round(avr / 3);
                    
                    // 4개의 무채색 톤으로 제한
                    if (grayValue < 64) {
                        grayValue = 40; // 매우 어두운 회색
                    } else if (grayValue < 128) {
                        grayValue = 80; // 어두운 회색
                    } else if (grayValue < 192) {
                        grayValue = 120; // 중간 회색
                    } else {
                        grayValue = 160; // 밝은 회색
                    }
                    
                    toData[pos] = grayValue;     // R
                    toData[pos + 1] = grayValue; // G
                    toData[pos + 2] = grayValue; // B
                    toData[pos + 3] = 255;       // A
                }
            }
            
            const newImage = new ImageData(toData, width, height);
            ctx.putImageData(newImage, 0, 0);
        }

        document.addEventListener('DOMContentLoaded', ()=>{
            window.scrollTo(0, 0);
            init();
            animate();
            initWebcam();
        });
        
        // 페이지 언로드 시 메모리 정리
        window.addEventListener('beforeunload', function() {
            cleanupProfileMemory();
        });
        
        // 페이지 숨김 시 메모리 정리 (탭 전환 등)
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                cleanupProfileMemory();
            }
        });

        // --- Entry Gate Logic --- //
        (function(){
            // 세션 동안 한 번만 보이게 하려면 true (원하면 false로 두고 매번 보이게)
            const showOncePerSession = false;
            const KEY = 'detox_entry_gate_done';

            const gate = document.getElementById('entry-gate');
            const secondGate = document.getElementById('second-gate');
            const thirdGate = document.getElementById('third-gate');
            const startBtn = document.getElementById('gate-start');
            const secondNextBtn = document.getElementById('second-next');
            const thirdStartBtn = document.getElementById('third-start');

            // 타자기 효과 함수
            function typeWriter(element, text, speed = 50) {
                // 기존 타이핑 중단
                if (element.typingTimeout) {
                    clearTimeout(element.typingTimeout);
                }
                
                element.innerHTML = '';
                element.classList.remove('completed');
                element.classList.add('typing');
                
                let i = 0;
                function type() {
                    if (i < text.length) {
                        const char = text.charAt(i);
                        if (char === '\n') {
                            element.innerHTML += '<br>';
                        } else {
                            element.innerHTML += char;
                        }
                        i++;
                        element.typingTimeout = setTimeout(type, speed);
                    } else {
                        element.classList.remove('typing');
                        element.classList.add('completed');
                        element.typingTimeout = null;
                    }
                }
                type();
            }

            function openGate(){
                if(!gate) return;
                document.body.classList.add('gate-lock');
                gate.classList.remove('hidden');
                gate.setAttribute('aria-hidden','false');
                
                // 첫 번째 게이트 타자기 효과
                const title1 = gate.querySelector('.gate-title');
                if (title1) {
                    typeWriter(title1, '오늘도 의미없이 스크롤을\n내리고 있지 않나요?', 80);
                }
            }

            function openSecondGate(){
                if(!secondGate) return;
                gate.classList.add('hidden');
                gate.setAttribute('aria-hidden','true');
                secondGate.classList.remove('hidden');
                secondGate.setAttribute('aria-hidden','false');
                
                // 두 번째 게이트 타자기 효과 (약간의 지연)
                setTimeout(() => {
                    const title2 = secondGate.querySelector('.gate-title');
                    if (title2) {
                        typeWriter(title2, '도파민에 절여진 뇌가\n어떻게 반응하는지 봅시다', 80);
                    }
                }, 100);
                
                // 프로필 게이지를 오버레이 위로 포털 이동
                portalizeProfileGauge();
            }
            
            function openThirdGate(){
                if(!thirdGate) return;
                secondGate.classList.add('hidden');
                secondGate.setAttribute('aria-hidden','true');
                thirdGate.classList.remove('hidden');
                thirdGate.setAttribute('aria-hidden','false');
                
                // 세 번째 게이트 타자기 효과 (약간의 지연)
                setTimeout(() => {
                    const title3 = thirdGate.querySelector('.gate-title');
                    if (title3) {
                        typeWriter(title3, '스크롤을 끝까지 내려주세요', 80);
                    }
                }, 100);
                
                // 프로필 게이지를 오버레이 위로 포털 이동
                portalizeProfileGauge();
            }
            
            // 프로필 게이지를 오버레이 위로 포털 이동
            function portalizeProfileGauge() {
                const gauge = document.querySelector('.profile-gauge');
                if (!gauge || gauge.classList.contains('portal')) return;

                // 현재 위치를 먼저 기억
                const r = gauge.getBoundingClientRect();
                
                // 원래 자리 보존용 placeholder (정확한 크기와 위치)
                const ph = document.createElement('div');
                ph.id = 'gauge-placeholder';
                ph.style.width = r.width + 'px';
                ph.style.height = r.height + 'px';
                ph.style.position = 'relative';
                ph.style.display = 'inline-block';
                gauge.parentNode.insertBefore(ph, gauge);

                // 포털 모드로 전환
                gauge.classList.add('portal');
                gauge.style.left = r.left + 'px';
                gauge.style.top = r.top + 'px';
                gauge.style.width = r.width + 'px';
                gauge.style.height = r.height + 'px';

                // 스태킹 컨텍스트에서 탈출
                document.body.appendChild(gauge);
            }

            // 포털로 뺀 걸 원래 자리로 복귀
            function restoreProfileGauge() {
                const gauge = document.querySelector('.profile-gauge.portal');
                const ph = document.getElementById('gauge-placeholder');
                if (!gauge || !ph) return;

                ph.parentNode.replaceChild(gauge, ph);
                gauge.classList.remove('portal');
                // 인라인 스타일 완전 초기화
                gauge.style.left = '';
                gauge.style.top = '';
                gauge.style.width = '';
                gauge.style.height = '';
            }

            function closeGate(){
                // 모든 게이트 닫기
                if(gate) {
                    gate.classList.add('hidden');
                    gate.setAttribute('aria-hidden','true');
                }
                if(secondGate) {
                    secondGate.classList.add('hidden');
                    secondGate.setAttribute('aria-hidden','true');
                }
                if(thirdGate) {
                    thirdGate.classList.add('hidden');
                    thirdGate.setAttribute('aria-hidden','true');
                }
                
                document.body.classList.remove('gate-lock');
                document.body.classList.add('gate-unlocked'); // 스크롤 허용

                // 오버레이 닫힐 때 원래 자리로 복귀
                restoreProfileGauge();

                if(showOncePerSession){
                    try{ sessionStorage.setItem(KEY, '1'); }catch(e){}
                }

                // 뇌 과부화 표시 활성화

            }

            function alreadyDone(){
                try{ return sessionStorage.getItem(KEY) === '1'; }catch(e){ return false; }
            }

            // 시작 이벤트들
            function handleStart(e){
                e.preventDefault();
                e.stopPropagation();
                openSecondGate();
            }

            function handleSecondNext(e){
                e.preventDefault();
                e.stopPropagation();
                openThirdGate();
            }
            
            function handleThirdStart(e){
                e.preventDefault();
                e.stopPropagation();
                closeGate();
                // 상단으로 확실히 정렬 (혹시 복원 켜진 브라우저 대비)
                setTimeout(()=>{ window.scrollTo(0,0); }, 0);
            }

            function onFirstInteraction(e){
                // 휠, 터치, 키(스페이스/엔터)로도 시작 가능
                if(e.type === 'keydown'){
                    const code = e.code || '';
                    if(!(code === 'Space' || code === 'Enter')) return;
                }
                removeFirstInteraction();
                handleStart();
            }

            function addFirstInteraction(){
                window.addEventListener('wheel', onFirstInteraction, { once:true });
                window.addEventListener('touchstart', onFirstInteraction, { once:true });
                window.addEventListener('keydown', onFirstInteraction);
            }
            function removeFirstInteraction(){
                window.removeEventListener('wheel', onFirstInteraction, { once:true });
                window.removeEventListener('touchstart', onFirstInteraction, { once:true });
                window.removeEventListener('keydown', onFirstInteraction);
            }

            // 초기 진입
            function initializeGate() {
                if(gate && !(showOncePerSession && alreadyDone())){
                    openGate();
                    addFirstInteraction();
                    if(startBtn){ 
                        // 기존 이벤트 제거
                        startBtn.removeEventListener('click', handleStart);
                        // 새 이벤트 추가
                        startBtn.addEventListener('click', handleStart, { once:true }); 
                        // 추가적인 클릭 이벤트 (확실성을 위해)
                        startBtn.onclick = handleStart;
                    }
                    if(secondNextBtn){ 
                        // 두 번째 게이트 버튼 이벤트
                        secondNextBtn.addEventListener('click', handleSecondNext, { once:true }); 
                        secondNextBtn.onclick = handleSecondNext;
                    }
                    if(thirdStartBtn){ 
                        // 세 번째 게이트 버튼 이벤트
                        thirdStartBtn.addEventListener('click', handleThirdStart, { once:true }); 
                        thirdStartBtn.onclick = handleThirdStart;
                    }
                }else{
                    // 게이트를 스킵하는 경우라도 뇌 과부화 표시 활성화
                    const brain = document.getElementById('brain-overload');
                    if(brain){ brain.style.opacity = '1'; }
                }
            }


            // DOM이 준비되면 즉시 실행
            if(document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeGate);
            } else {
                initializeGate();
            }
        })();

        // ===== 사이드바 원형 게이지 연동 (수정版) =====
        (function(){
          const fill = document.getElementById('gauge-fill');
          const label = document.getElementById('sidebar-overload');
          const overloadSpan = document.getElementById('overload-percentage');

          if(!fill || !label || !overloadSpan) return;

          // SVG circle의 실제 r 값으로 원둘레 계산 (r="62")
          const R = parseFloat(fill.getAttribute('r')) || 62;
          const C = 2 * Math.PI * R;

          // 초기 dasharray/offset 세팅: 0%에서 비어 있고, 100%에서 가득 차도록
          fill.style.strokeDasharray = String(C);
          fill.style.strokeDashoffset = String(C);

          function setGauge(percent){
            let p = Number(percent);
            if (isNaN(p)) p = 0;
            p = Math.max(0, Math.min(100, p));

            // 선형 매핑: 100 → 완전 채움
            const eased = p / 100;   // 필요하면 1.15~1.3 같은 지수로 살짝 완만하게 가능
            const offset = C * (1 - eased);

            fill.style.strokeDashoffset = String(offset);
            label.textContent = String(Math.round(p));

            // 게이지 업데이트 시 글리치 효과 트리거
            triggerProfileGlitch(p);
          }

          function triggerProfileGlitch(percent){
            const profileGauge = document.querySelector('.profile-gauge');
            if(!profileGauge) return;

            // 100%에 도달하면 연속 글리치 효과
            if(percent >= 100) {
              // 기존 타이머 정리
              if(window.glitchTimer) {
                clearInterval(window.glitchTimer);
              }
              
              // 연속 글리치 효과 시작 (더 긴 간격으로)
              const startContinuousGlitch = () => {
                profileGauge.classList.remove('glitch', 'mild', 'moderate', 'severe');
                requestAnimationFrame(() => {
                  profileGauge.classList.add('glitch', 'severe');
                });
              };
              
              // 즉시 시작하고 1.2초마다 반복 (더 긴 간격)
              startContinuousGlitch();
              window.glitchTimer = setInterval(startContinuousGlitch, 1200);
              return;
            }

            // 100% 미만일 때는 기존 타이머 정리
            if(window.glitchTimer) {
              clearInterval(window.glitchTimer);
              window.glitchTimer = null;
            }

            // 퍼센트에 따른 글리치 강도 결정
            let intensity = 'mild';
            if(percent >= 70) {
              intensity = 'severe';
            } else if(percent >= 30) {
              intensity = 'moderate';
            }

            // 기존 글리치 클래스들 제거
            profileGauge.classList.remove('glitch', 'mild', 'moderate', 'severe');
            
            // 다음 프레임에서 글리치 클래스 추가 (애니메이션 재시작)
            requestAnimationFrame(() => {
              profileGauge.classList.add('glitch', intensity);
              
              // 애니메이션 완료 후 클래스 제거
              setTimeout(() => {
                profileGauge.classList.remove('glitch', 'mild', 'moderate', 'severe');
              }, 300);
            });
          }

          // 초기 동기화
          setGauge(overloadSpan.textContent);

          // #overload-percentage 값 변화를 감지해 반영
          const mo = new MutationObserver(()=> setGauge(overloadSpan.textContent));
          mo.observe(overloadSpan, { childList:true, characterData:true, subtree:true });

          // 안전 보정 (throttle 적용)
          let gaugeUpdateTimer = null;
          const throttledGaugeUpdate = () => {
            if(gaugeUpdateTimer) return;
            gaugeUpdateTimer = setTimeout(() => {
              setGauge(overloadSpan.textContent);
              gaugeUpdateTimer = null;
            }, 16); // 60fps로 제한
          };
          
          window.addEventListener('scroll', throttledGaugeUpdate, { passive: true });
          window.addEventListener('resize', throttledGaugeUpdate);
        })();

        // ===== Vacuum Cursor Follower =====
        (function(){
          const vacWrap = document.getElementById('vacuum-cursor'); // 회전 X
          const vacImg  = document.getElementById('vacuum-img');    // 회전 O
          if(!vacWrap || !vacImg) return;

          // 마우스(=청소기) 위치
          let mouseX = window.innerWidth * 0.5;
          let mouseY = window.innerHeight * 0.5;
          let prevMouseX = mouseX;
          let prevMouseY = mouseY;
          let rotationAngle = 0;

          // 회전 적용 함수
          function applyVacuumRotation(deg){
            vacImg.style.transform = `rotate(${deg}deg)`;
          }

          // 마우스 이동 = 청소기 이동
          document.addEventListener('mousemove', e=>{
            mouseX = e.clientX; 
            mouseY = e.clientY;
            
            if(!document.body.classList.contains('cleaning-mode')){
              vacWrap.style.display = 'none'; 
              return;
            }
            
            vacWrap.style.display = 'block';
            vacWrap.style.left = mouseX + 'px';
            vacWrap.style.top  = mouseY + 'px';
            
            // 마우스 이동 방향으로 회전
            const deltaX = mouseX - prevMouseX;
            const deltaY = mouseY - prevMouseY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > 5) {
              const angle = Math.atan2(deltaY, deltaX);
              let targetAngle = angle * (180 / Math.PI);
              
              // 회전 각도 제한 (-90도 ~ +90도)
              if (targetAngle > 90) {
                targetAngle = 90;
              } else if (targetAngle < -90) {
                targetAngle = -90;
              }
              
              rotationAngle = rotationAngle * 0.8 + targetAngle * 0.2;
              applyVacuumRotation(rotationAngle);
            }
            
            prevMouseX = mouseX;
            prevMouseY = mouseY;
          });

          document.addEventListener('mouseleave', ()=>{
            vacWrap.style.display = 'none';
          });
        })();
    </script>
</body>
</html>
